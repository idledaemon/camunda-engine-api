/*
Camunda Platform REST API

OpenApi Spec for Camunda Platform REST API.

API version: 7.21.2-ee
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package camundarestgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FilterAPI interface {

	/*
	CreateFilter Create Filter

	Creates a new filter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateFilterRequest
	*/
	CreateFilter(ctx context.Context) ApiCreateFilterRequest

	// CreateFilterExecute executes the request
	//  @return FilterDto
	CreateFilterExecute(r ApiCreateFilterRequest) (*FilterDto, *http.Response, error)

	/*
	DeleteFilter Delete Filter

	Deletes a filter by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to be deleted.
	@return ApiDeleteFilterRequest
	*/
	DeleteFilter(ctx context.Context, id string) ApiDeleteFilterRequest

	// DeleteFilterExecute executes the request
	DeleteFilterExecute(r ApiDeleteFilterRequest) (*http.Response, error)

	/*
	ExecuteFilterCount Execute Filter Count

	Executes the saved query of the filter by id and returns the count.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to execute.
	@return ApiExecuteFilterCountRequest
	*/
	ExecuteFilterCount(ctx context.Context, id string) ApiExecuteFilterCountRequest

	// ExecuteFilterCountExecute executes the request
	//  @return CountResultDto
	ExecuteFilterCountExecute(r ApiExecuteFilterCountRequest) (*CountResultDto, *http.Response, error)

	/*
	ExecuteFilterList Execute Filter List

	Executes the saved query of the filter by id and returns the result list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to execute.
	@return ApiExecuteFilterListRequest
	*/
	ExecuteFilterList(ctx context.Context, id string) ApiExecuteFilterListRequest

	// ExecuteFilterListExecute executes the request
	//  @return []map[string]interface{}
	ExecuteFilterListExecute(r ApiExecuteFilterListRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	ExecuteFilterSingleResult Execute Filter Single Result

	Executes the saved query of the filter by id and returns the single result.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to execute.
	@return ApiExecuteFilterSingleResultRequest
	*/
	ExecuteFilterSingleResult(ctx context.Context, id string) ApiExecuteFilterSingleResultRequest

	// ExecuteFilterSingleResultExecute executes the request
	//  @return map[string]interface{}
	ExecuteFilterSingleResultExecute(r ApiExecuteFilterSingleResultRequest) (map[string]interface{}, *http.Response, error)

	/*
	FilterResourceOptions Filter Resource Options

	The OPTIONS request allows you to check for the set of available operations 
that the currently authenticated user can perform on the `/filter` resource.
Whether the user can perform an operation or not may depend on various
factors, including the users authorizations to interact with this
resource and the internal configuration of the process engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFilterResourceOptionsRequest
	*/
	FilterResourceOptions(ctx context.Context) ApiFilterResourceOptionsRequest

	// FilterResourceOptionsExecute executes the request
	//  @return ResourceOptionsDto
	FilterResourceOptionsExecute(r ApiFilterResourceOptionsRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	FilterResourceOptionsSingle Filter Resource Options

	The OPTIONS request allows you to check for the set of available operations 
that the currently authenticated user can perform on the `/filter` resource.
Whether the user can perform an operation or not may depend on various
factors, including the users authorizations to interact with this
resource and the internal configuration of the process engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to be checked.
	@return ApiFilterResourceOptionsSingleRequest
	*/
	FilterResourceOptionsSingle(ctx context.Context, id string) ApiFilterResourceOptionsSingleRequest

	// FilterResourceOptionsSingleExecute executes the request
	//  @return ResourceOptionsDto
	FilterResourceOptionsSingleExecute(r ApiFilterResourceOptionsSingleRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	GetFilterCount Get Filter Count

	Retrieves the number of filters that fulfill a provided query. Corresponds to the
size of the result set when using the 
[Get Filters](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-query/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFilterCountRequest
	*/
	GetFilterCount(ctx context.Context) ApiGetFilterCountRequest

	// GetFilterCountExecute executes the request
	//  @return CountResultDto
	GetFilterCountExecute(r ApiGetFilterCountRequest) (*CountResultDto, *http.Response, error)

	/*
	GetFilterList Get Filters

	Queries for a list of filters using a list of parameters. The size of the result
set can be retrieved
by using the [Get Filter Count](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFilterListRequest
	*/
	GetFilterList(ctx context.Context) ApiGetFilterListRequest

	// GetFilterListExecute executes the request
	//  @return []FilterDto
	GetFilterListExecute(r ApiGetFilterListRequest) ([]FilterDto, *http.Response, error)

	/*
	GetSingleFilter Get Single Filter

	Retrieves a single filter by id, according to the `Filter` interface in the engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to be retrieved.
	@return ApiGetSingleFilterRequest
	*/
	GetSingleFilter(ctx context.Context, id string) ApiGetSingleFilterRequest

	// GetSingleFilterExecute executes the request
	//  @return FilterDto
	GetSingleFilterExecute(r ApiGetSingleFilterRequest) (*FilterDto, *http.Response, error)

	/*
	PostExecuteFilterCount Execute Filter Count (POST)

	Executes the saved query of the filter by id and returns the count. This method is
slightly more powerful then the [Get Execute Filter Count](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-execute-count/) 
method because it allows to extend the saved query of the filter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to execute.
	@return ApiPostExecuteFilterCountRequest
	*/
	PostExecuteFilterCount(ctx context.Context, id string) ApiPostExecuteFilterCountRequest

	// PostExecuteFilterCountExecute executes the request
	//  @return CountResultDto
	PostExecuteFilterCountExecute(r ApiPostExecuteFilterCountRequest) (*CountResultDto, *http.Response, error)

	/*
	PostExecuteFilterList Execute Filter List (POST)

	Executes the saved query of the filter by id and returns the result list. This
method is slightly more powerful then the 
[Get Execute FilterList](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-execute-list/) method
because it allows to extend the saved query of the filter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to execute.
	@return ApiPostExecuteFilterListRequest
	*/
	PostExecuteFilterList(ctx context.Context, id string) ApiPostExecuteFilterListRequest

	// PostExecuteFilterListExecute executes the request
	//  @return []map[string]interface{}
	PostExecuteFilterListExecute(r ApiPostExecuteFilterListRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	PostExecuteFilterSingleResult Execute Filter Single Result (POST)

	Executes the saved query of the filter by id and returns the single result. This method is slightly more
powerful then the [Get Execute Filter Single Result](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-execute-single-result/)
method because it allows to extend the saved query of the filter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to execute.
	@return ApiPostExecuteFilterSingleResultRequest
	*/
	PostExecuteFilterSingleResult(ctx context.Context, id string) ApiPostExecuteFilterSingleResultRequest

	// PostExecuteFilterSingleResultExecute executes the request
	//  @return map[string]interface{}
	PostExecuteFilterSingleResultExecute(r ApiPostExecuteFilterSingleResultRequest) (map[string]interface{}, *http.Response, error)

	/*
	UpdateFilter Update Filter

	Updates an existing filter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the filter to be updated.
	@return ApiUpdateFilterRequest
	*/
	UpdateFilter(ctx context.Context, id string) ApiUpdateFilterRequest

	// UpdateFilterExecute executes the request
	UpdateFilterExecute(r ApiUpdateFilterRequest) (*http.Response, error)
}

// FilterAPIService FilterAPI service
type FilterAPIService service

type ApiCreateFilterRequest struct {
	ctx context.Context
	ApiService FilterAPI
	createFilterDto *CreateFilterDto
}

func (r ApiCreateFilterRequest) CreateFilterDto(createFilterDto CreateFilterDto) ApiCreateFilterRequest {
	r.createFilterDto = &createFilterDto
	return r
}

func (r ApiCreateFilterRequest) Execute() (*FilterDto, *http.Response, error) {
	return r.ApiService.CreateFilterExecute(r)
}

/*
CreateFilter Create Filter

Creates a new filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFilterRequest
*/
func (a *FilterAPIService) CreateFilter(ctx context.Context) ApiCreateFilterRequest {
	return ApiCreateFilterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilterDto
func (a *FilterAPIService) CreateFilterExecute(r ApiCreateFilterRequest) (*FilterDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.CreateFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFilterDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFilterRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
}

func (r ApiDeleteFilterRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFilterExecute(r)
}

/*
DeleteFilter Delete Filter

Deletes a filter by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to be deleted.
 @return ApiDeleteFilterRequest
*/
func (a *FilterAPIService) DeleteFilter(ctx context.Context, id string) ApiDeleteFilterRequest {
	return ApiDeleteFilterRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FilterAPIService) DeleteFilterExecute(r ApiDeleteFilterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.DeleteFilter")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExecuteFilterCountRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
}

func (r ApiExecuteFilterCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.ExecuteFilterCountExecute(r)
}

/*
ExecuteFilterCount Execute Filter Count

Executes the saved query of the filter by id and returns the count.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to execute.
 @return ApiExecuteFilterCountRequest
*/
func (a *FilterAPIService) ExecuteFilterCount(ctx context.Context, id string) ApiExecuteFilterCountRequest {
	return ApiExecuteFilterCountRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *FilterAPIService) ExecuteFilterCountExecute(r ApiExecuteFilterCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.ExecuteFilterCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}/count"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExecuteFilterListRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
	firstResult *int32
	maxResults *int32
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiExecuteFilterListRequest) FirstResult(firstResult int32) ApiExecuteFilterListRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiExecuteFilterListRequest) MaxResults(maxResults int32) ApiExecuteFilterListRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiExecuteFilterListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ExecuteFilterListExecute(r)
}

/*
ExecuteFilterList Execute Filter List

Executes the saved query of the filter by id and returns the result list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to execute.
 @return ApiExecuteFilterListRequest
*/
func (a *FilterAPIService) ExecuteFilterList(ctx context.Context, id string) ApiExecuteFilterListRequest {
	return ApiExecuteFilterListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *FilterAPIService) ExecuteFilterListExecute(r ApiExecuteFilterListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.ExecuteFilterList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExecuteFilterSingleResultRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
}

func (r ApiExecuteFilterSingleResultRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ExecuteFilterSingleResultExecute(r)
}

/*
ExecuteFilterSingleResult Execute Filter Single Result

Executes the saved query of the filter by id and returns the single result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to execute.
 @return ApiExecuteFilterSingleResultRequest
*/
func (a *FilterAPIService) ExecuteFilterSingleResult(ctx context.Context, id string) ApiExecuteFilterSingleResultRequest {
	return ApiExecuteFilterSingleResultRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FilterAPIService) ExecuteFilterSingleResultExecute(r ApiExecuteFilterSingleResultRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.ExecuteFilterSingleResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}/singleResult"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilterResourceOptionsRequest struct {
	ctx context.Context
	ApiService FilterAPI
}

func (r ApiFilterResourceOptionsRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.FilterResourceOptionsExecute(r)
}

/*
FilterResourceOptions Filter Resource Options

The OPTIONS request allows you to check for the set of available operations 
that the currently authenticated user can perform on the `/filter` resource.
Whether the user can perform an operation or not may depend on various
factors, including the users authorizations to interact with this
resource and the internal configuration of the process engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFilterResourceOptionsRequest
*/
func (a *FilterAPIService) FilterResourceOptions(ctx context.Context) ApiFilterResourceOptionsRequest {
	return ApiFilterResourceOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *FilterAPIService) FilterResourceOptionsExecute(r ApiFilterResourceOptionsRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.FilterResourceOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilterResourceOptionsSingleRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
}

func (r ApiFilterResourceOptionsSingleRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.FilterResourceOptionsSingleExecute(r)
}

/*
FilterResourceOptionsSingle Filter Resource Options

The OPTIONS request allows you to check for the set of available operations 
that the currently authenticated user can perform on the `/filter` resource.
Whether the user can perform an operation or not may depend on various
factors, including the users authorizations to interact with this
resource and the internal configuration of the process engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to be checked.
 @return ApiFilterResourceOptionsSingleRequest
*/
func (a *FilterAPIService) FilterResourceOptionsSingle(ctx context.Context, id string) ApiFilterResourceOptionsSingleRequest {
	return ApiFilterResourceOptionsSingleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *FilterAPIService) FilterResourceOptionsSingleExecute(r ApiFilterResourceOptionsSingleRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.FilterResourceOptionsSingle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilterCountRequest struct {
	ctx context.Context
	ApiService FilterAPI
	filterId *string
	resourceType *string
	name *string
	nameLike *string
	owner *string
}

// Filter by the id of the filter.
func (r ApiGetFilterCountRequest) FilterId(filterId string) ApiGetFilterCountRequest {
	r.filterId = &filterId
	return r
}

// Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
func (r ApiGetFilterCountRequest) ResourceType(resourceType string) ApiGetFilterCountRequest {
	r.resourceType = &resourceType
	return r
}

// Filter by the name of the filter.
func (r ApiGetFilterCountRequest) Name(name string) ApiGetFilterCountRequest {
	r.name = &name
	return r
}

// Filter by the name that the parameter is a substring of.
func (r ApiGetFilterCountRequest) NameLike(nameLike string) ApiGetFilterCountRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the user id of the owner of the filter.
func (r ApiGetFilterCountRequest) Owner(owner string) ApiGetFilterCountRequest {
	r.owner = &owner
	return r
}

func (r ApiGetFilterCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetFilterCountExecute(r)
}

/*
GetFilterCount Get Filter Count

Retrieves the number of filters that fulfill a provided query. Corresponds to the
size of the result set when using the 
[Get Filters](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFilterCountRequest
*/
func (a *FilterAPIService) GetFilterCount(ctx context.Context) ApiGetFilterCountRequest {
	return ApiGetFilterCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *FilterAPIService) GetFilterCountExecute(r ApiGetFilterCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.GetFilterCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterId", r.filterId, "")
	}
	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceType", r.resourceType, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilterListRequest struct {
	ctx context.Context
	ApiService FilterAPI
	filterId *string
	resourceType *string
	name *string
	nameLike *string
	owner *string
	itemCount *bool
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Filter by the id of the filter.
func (r ApiGetFilterListRequest) FilterId(filterId string) ApiGetFilterListRequest {
	r.filterId = &filterId
	return r
}

// Filter by the resource type of the filter, e.g., &#x60;Task&#x60;.
func (r ApiGetFilterListRequest) ResourceType(resourceType string) ApiGetFilterListRequest {
	r.resourceType = &resourceType
	return r
}

// Filter by the name of the filter.
func (r ApiGetFilterListRequest) Name(name string) ApiGetFilterListRequest {
	r.name = &name
	return r
}

// Filter by the name that the parameter is a substring of.
func (r ApiGetFilterListRequest) NameLike(nameLike string) ApiGetFilterListRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the user id of the owner of the filter.
func (r ApiGetFilterListRequest) Owner(owner string) ApiGetFilterListRequest {
	r.owner = &owner
	return r
}

// If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
func (r ApiGetFilterListRequest) ItemCount(itemCount bool) ApiGetFilterListRequest {
	r.itemCount = &itemCount
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetFilterListRequest) SortBy(sortBy string) ApiGetFilterListRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetFilterListRequest) SortOrder(sortOrder string) ApiGetFilterListRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetFilterListRequest) FirstResult(firstResult int32) ApiGetFilterListRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetFilterListRequest) MaxResults(maxResults int32) ApiGetFilterListRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetFilterListRequest) Execute() ([]FilterDto, *http.Response, error) {
	return r.ApiService.GetFilterListExecute(r)
}

/*
GetFilterList Get Filters

Queries for a list of filters using a list of parameters. The size of the result
set can be retrieved
by using the [Get Filter Count](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFilterListRequest
*/
func (a *FilterAPIService) GetFilterList(ctx context.Context) ApiGetFilterListRequest {
	return ApiGetFilterListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FilterDto
func (a *FilterAPIService) GetFilterListExecute(r ApiGetFilterListRequest) ([]FilterDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FilterDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.GetFilterList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterId", r.filterId, "")
	}
	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceType", r.resourceType, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	}
	if r.itemCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemCount", r.itemCount, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSingleFilterRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
	itemCount *bool
}

// If set to &#x60;true&#x60;, each filter result will contain an &#x60;itemCount&#x60; property with the number of items matched by the filter itself.
func (r ApiGetSingleFilterRequest) ItemCount(itemCount bool) ApiGetSingleFilterRequest {
	r.itemCount = &itemCount
	return r
}

func (r ApiGetSingleFilterRequest) Execute() (*FilterDto, *http.Response, error) {
	return r.ApiService.GetSingleFilterExecute(r)
}

/*
GetSingleFilter Get Single Filter

Retrieves a single filter by id, according to the `Filter` interface in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to be retrieved.
 @return ApiGetSingleFilterRequest
*/
func (a *FilterAPIService) GetSingleFilter(ctx context.Context, id string) ApiGetSingleFilterRequest {
	return ApiGetSingleFilterRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FilterDto
func (a *FilterAPIService) GetSingleFilterExecute(r ApiGetSingleFilterRequest) (*FilterDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.GetSingleFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.itemCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemCount", r.itemCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostExecuteFilterCountRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
	body *map[string]interface{}
}

// A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
func (r ApiPostExecuteFilterCountRequest) Body(body map[string]interface{}) ApiPostExecuteFilterCountRequest {
	r.body = &body
	return r
}

func (r ApiPostExecuteFilterCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.PostExecuteFilterCountExecute(r)
}

/*
PostExecuteFilterCount Execute Filter Count (POST)

Executes the saved query of the filter by id and returns the count. This method is
slightly more powerful then the [Get Execute Filter Count](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-execute-count/) 
method because it allows to extend the saved query of the filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to execute.
 @return ApiPostExecuteFilterCountRequest
*/
func (a *FilterAPIService) PostExecuteFilterCount(ctx context.Context, id string) ApiPostExecuteFilterCountRequest {
	return ApiPostExecuteFilterCountRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *FilterAPIService) PostExecuteFilterCountExecute(r ApiPostExecuteFilterCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.PostExecuteFilterCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}/count"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostExecuteFilterListRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
	firstResult *int32
	maxResults *int32
	body *map[string]interface{}
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiPostExecuteFilterListRequest) FirstResult(firstResult int32) ApiPostExecuteFilterListRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiPostExecuteFilterListRequest) MaxResults(maxResults int32) ApiPostExecuteFilterListRequest {
	r.maxResults = &maxResults
	return r
}

// A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
func (r ApiPostExecuteFilterListRequest) Body(body map[string]interface{}) ApiPostExecuteFilterListRequest {
	r.body = &body
	return r
}

func (r ApiPostExecuteFilterListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostExecuteFilterListExecute(r)
}

/*
PostExecuteFilterList Execute Filter List (POST)

Executes the saved query of the filter by id and returns the result list. This
method is slightly more powerful then the 
[Get Execute FilterList](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-execute-list/) method
because it allows to extend the saved query of the filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to execute.
 @return ApiPostExecuteFilterListRequest
*/
func (a *FilterAPIService) PostExecuteFilterList(ctx context.Context, id string) ApiPostExecuteFilterListRequest {
	return ApiPostExecuteFilterListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *FilterAPIService) PostExecuteFilterListExecute(r ApiPostExecuteFilterListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.PostExecuteFilterList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostExecuteFilterSingleResultRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
	body *map[string]interface{}
}

// A JSON object which corresponds to the type of the saved query of the filter, i.e., if the resource type of the filter is Task the body should form a valid task query corresponding to the Task resource.
func (r ApiPostExecuteFilterSingleResultRequest) Body(body map[string]interface{}) ApiPostExecuteFilterSingleResultRequest {
	r.body = &body
	return r
}

func (r ApiPostExecuteFilterSingleResultRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostExecuteFilterSingleResultExecute(r)
}

/*
PostExecuteFilterSingleResult Execute Filter Single Result (POST)

Executes the saved query of the filter by id and returns the single result. This method is slightly more
powerful then the [Get Execute Filter Single Result](https://docs.camunda.org/manual/7.21/reference/rest/filter/get-execute-single-result/)
method because it allows to extend the saved query of the filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to execute.
 @return ApiPostExecuteFilterSingleResultRequest
*/
func (a *FilterAPIService) PostExecuteFilterSingleResult(ctx context.Context, id string) ApiPostExecuteFilterSingleResultRequest {
	return ApiPostExecuteFilterSingleResultRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FilterAPIService) PostExecuteFilterSingleResultExecute(r ApiPostExecuteFilterSingleResultRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.PostExecuteFilterSingleResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}/singleResult"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFilterRequest struct {
	ctx context.Context
	ApiService FilterAPI
	id string
	createFilterDto *CreateFilterDto
}

func (r ApiUpdateFilterRequest) CreateFilterDto(createFilterDto CreateFilterDto) ApiUpdateFilterRequest {
	r.createFilterDto = &createFilterDto
	return r
}

func (r ApiUpdateFilterRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateFilterExecute(r)
}

/*
UpdateFilter Update Filter

Updates an existing filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the filter to be updated.
 @return ApiUpdateFilterRequest
*/
func (a *FilterAPIService) UpdateFilter(ctx context.Context, id string) ApiUpdateFilterRequest {
	return ApiUpdateFilterRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FilterAPIService) UpdateFilterExecute(r ApiUpdateFilterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.UpdateFilter")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFilterDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
