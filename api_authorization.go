/*
Camunda Platform REST API

OpenApi Spec for Camunda Platform REST API.

API version: 7.21.2-ee
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package camundarestgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AuthorizationAPI interface {

	/*
	AvailableOperationsAuthorization Authorization Resource Options

	The OPTIONS request allows you to check for the set of available operations that the currently
authenticated user can perform on the `/authorization` resource. Whether the user can perform an operation
or not may depend on various factors, including the users authorizations to interact with this
resource and the internal configuration of the process engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAvailableOperationsAuthorizationRequest
	*/
	AvailableOperationsAuthorization(ctx context.Context) ApiAvailableOperationsAuthorizationRequest

	// AvailableOperationsAuthorizationExecute executes the request
	//  @return ResourceOptionsDto
	AvailableOperationsAuthorizationExecute(r ApiAvailableOperationsAuthorizationRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	AvailableOperationsAuthorizationInstance Authorization Resource Options

	The OPTIONS request allows you to check for the set of available operations that the currently
authenticated user can perform on a given instance of the `/authorization` resource.
Whether the user can perform an operation or not may depend on various factors, including the users
authorizations to interact with this resource and the internal configuration of the process engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the authorization to be retrieved.
	@return ApiAvailableOperationsAuthorizationInstanceRequest
	*/
	AvailableOperationsAuthorizationInstance(ctx context.Context, id string) ApiAvailableOperationsAuthorizationInstanceRequest

	// AvailableOperationsAuthorizationInstanceExecute executes the request
	//  @return ResourceOptionsDto
	AvailableOperationsAuthorizationInstanceExecute(r ApiAvailableOperationsAuthorizationInstanceRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	CreateAuthorization Create a New Authorization

	Creates a new authorization.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateAuthorizationRequest
	*/
	CreateAuthorization(ctx context.Context) ApiCreateAuthorizationRequest

	// CreateAuthorizationExecute executes the request
	//  @return AuthorizationDto
	CreateAuthorizationExecute(r ApiCreateAuthorizationRequest) (*AuthorizationDto, *http.Response, error)

	/*
	DeleteAuthorization Delete Authorization

	Deletes an authorization by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the authorization to be deleted.
	@return ApiDeleteAuthorizationRequest
	*/
	DeleteAuthorization(ctx context.Context, id string) ApiDeleteAuthorizationRequest

	// DeleteAuthorizationExecute executes the request
	DeleteAuthorizationExecute(r ApiDeleteAuthorizationRequest) (*http.Response, error)

	/*
	GetAuthorization Get Authorization

	Retrieves an authorization by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the authorization to be retrieved.
	@return ApiGetAuthorizationRequest
	*/
	GetAuthorization(ctx context.Context, id string) ApiGetAuthorizationRequest

	// GetAuthorizationExecute executes the request
	//  @return AuthorizationDto
	GetAuthorizationExecute(r ApiGetAuthorizationRequest) (*AuthorizationDto, *http.Response, error)

	/*
	GetAuthorizationCount Get Authorization Count

	Queries for authorizations using a list of parameters and retrieves the count.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAuthorizationCountRequest
	*/
	GetAuthorizationCount(ctx context.Context) ApiGetAuthorizationCountRequest

	// GetAuthorizationCountExecute executes the request
	//  @return CountResultDto
	GetAuthorizationCountExecute(r ApiGetAuthorizationCountRequest) (*CountResultDto, *http.Response, error)

	/*
	IsUserAuthorized Perform an Authorization Check

	Performs an authorization check for the currently authenticated user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIsUserAuthorizedRequest
	*/
	IsUserAuthorized(ctx context.Context) ApiIsUserAuthorizedRequest

	// IsUserAuthorizedExecute executes the request
	//  @return AuthorizationCheckResultDto
	IsUserAuthorizedExecute(r ApiIsUserAuthorizedRequest) (*AuthorizationCheckResultDto, *http.Response, error)

	/*
	QueryAuthorizations Get Authorizations

	Queries for a list of authorizations using a list of parameters.
The size of the result set can be retrieved by using the
[Get Authorization Count](https://docs.camunda.org/manual/7.21/reference/rest/authorization/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryAuthorizationsRequest
	*/
	QueryAuthorizations(ctx context.Context) ApiQueryAuthorizationsRequest

	// QueryAuthorizationsExecute executes the request
	//  @return []AuthorizationDto
	QueryAuthorizationsExecute(r ApiQueryAuthorizationsRequest) ([]AuthorizationDto, *http.Response, error)

	/*
	UpdateAuthorization Update an Authorization

	Updates an authorization by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the authorization to be updated.
	@return ApiUpdateAuthorizationRequest
	*/
	UpdateAuthorization(ctx context.Context, id string) ApiUpdateAuthorizationRequest

	// UpdateAuthorizationExecute executes the request
	UpdateAuthorizationExecute(r ApiUpdateAuthorizationRequest) (*http.Response, error)
}

// AuthorizationAPIService AuthorizationAPI service
type AuthorizationAPIService service

type ApiAvailableOperationsAuthorizationRequest struct {
	ctx context.Context
	ApiService AuthorizationAPI
}

func (r ApiAvailableOperationsAuthorizationRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.AvailableOperationsAuthorizationExecute(r)
}

/*
AvailableOperationsAuthorization Authorization Resource Options

The OPTIONS request allows you to check for the set of available operations that the currently
authenticated user can perform on the `/authorization` resource. Whether the user can perform an operation
or not may depend on various factors, including the users authorizations to interact with this
resource and the internal configuration of the process engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAvailableOperationsAuthorizationRequest
*/
func (a *AuthorizationAPIService) AvailableOperationsAuthorization(ctx context.Context) ApiAvailableOperationsAuthorizationRequest {
	return ApiAvailableOperationsAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *AuthorizationAPIService) AvailableOperationsAuthorizationExecute(r ApiAvailableOperationsAuthorizationRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.AvailableOperationsAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAvailableOperationsAuthorizationInstanceRequest struct {
	ctx context.Context
	ApiService AuthorizationAPI
	id string
}

func (r ApiAvailableOperationsAuthorizationInstanceRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.AvailableOperationsAuthorizationInstanceExecute(r)
}

/*
AvailableOperationsAuthorizationInstance Authorization Resource Options

The OPTIONS request allows you to check for the set of available operations that the currently
authenticated user can perform on a given instance of the `/authorization` resource.
Whether the user can perform an operation or not may depend on various factors, including the users
authorizations to interact with this resource and the internal configuration of the process engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the authorization to be retrieved.
 @return ApiAvailableOperationsAuthorizationInstanceRequest
*/
func (a *AuthorizationAPIService) AvailableOperationsAuthorizationInstance(ctx context.Context, id string) ApiAvailableOperationsAuthorizationInstanceRequest {
	return ApiAvailableOperationsAuthorizationInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *AuthorizationAPIService) AvailableOperationsAuthorizationInstanceExecute(r ApiAvailableOperationsAuthorizationInstanceRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.AvailableOperationsAuthorizationInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorization/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationRequest struct {
	ctx context.Context
	ApiService AuthorizationAPI
	authorizationCreateDto *AuthorizationCreateDto
}

func (r ApiCreateAuthorizationRequest) AuthorizationCreateDto(authorizationCreateDto AuthorizationCreateDto) ApiCreateAuthorizationRequest {
	r.authorizationCreateDto = &authorizationCreateDto
	return r
}

func (r ApiCreateAuthorizationRequest) Execute() (*AuthorizationDto, *http.Response, error) {
	return r.ApiService.CreateAuthorizationExecute(r)
}

/*
CreateAuthorization Create a New Authorization

Creates a new authorization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthorizationRequest
*/
func (a *AuthorizationAPIService) CreateAuthorization(ctx context.Context) ApiCreateAuthorizationRequest {
	return ApiCreateAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthorizationDto
func (a *AuthorizationAPIService) CreateAuthorizationExecute(r ApiCreateAuthorizationRequest) (*AuthorizationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.CreateAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorization/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationCreateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuthorizationRequest struct {
	ctx context.Context
	ApiService AuthorizationAPI
	id string
}

func (r ApiDeleteAuthorizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAuthorizationExecute(r)
}

/*
DeleteAuthorization Delete Authorization

Deletes an authorization by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the authorization to be deleted.
 @return ApiDeleteAuthorizationRequest
*/
func (a *AuthorizationAPIService) DeleteAuthorization(ctx context.Context, id string) ApiDeleteAuthorizationRequest {
	return ApiDeleteAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AuthorizationAPIService) DeleteAuthorizationExecute(r ApiDeleteAuthorizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.DeleteAuthorization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorization/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAuthorizationRequest struct {
	ctx context.Context
	ApiService AuthorizationAPI
	id string
}

func (r ApiGetAuthorizationRequest) Execute() (*AuthorizationDto, *http.Response, error) {
	return r.ApiService.GetAuthorizationExecute(r)
}

/*
GetAuthorization Get Authorization

Retrieves an authorization by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the authorization to be retrieved.
 @return ApiGetAuthorizationRequest
*/
func (a *AuthorizationAPIService) GetAuthorization(ctx context.Context, id string) ApiGetAuthorizationRequest {
	return ApiGetAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AuthorizationDto
func (a *AuthorizationAPIService) GetAuthorizationExecute(r ApiGetAuthorizationRequest) (*AuthorizationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.GetAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorization/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthorizationCountRequest struct {
	ctx context.Context
	ApiService AuthorizationAPI
	id *string
	type_ *int32
	userIdIn *string
	groupIdIn *string
	resourceType *int32
	resourceId *string
}

// Filter by the id of the authorization.
func (r ApiGetAuthorizationCountRequest) Id(id string) ApiGetAuthorizationCountRequest {
	r.id = &id
	return r
}

// Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
func (r ApiGetAuthorizationCountRequest) Type_(type_ int32) ApiGetAuthorizationCountRequest {
	r.type_ = &type_
	return r
}

// Filter by a comma-separated list of userIds.
func (r ApiGetAuthorizationCountRequest) UserIdIn(userIdIn string) ApiGetAuthorizationCountRequest {
	r.userIdIn = &userIdIn
	return r
}

// Filter by a comma-separated list of groupIds.
func (r ApiGetAuthorizationCountRequest) GroupIdIn(groupIdIn string) ApiGetAuthorizationCountRequest {
	r.groupIdIn = &groupIdIn
	return r
}

// Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
func (r ApiGetAuthorizationCountRequest) ResourceType(resourceType int32) ApiGetAuthorizationCountRequest {
	r.resourceType = &resourceType
	return r
}

// Filter by resource id.
func (r ApiGetAuthorizationCountRequest) ResourceId(resourceId string) ApiGetAuthorizationCountRequest {
	r.resourceId = &resourceId
	return r
}

func (r ApiGetAuthorizationCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetAuthorizationCountExecute(r)
}

/*
GetAuthorizationCount Get Authorization Count

Queries for authorizations using a list of parameters and retrieves the count.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuthorizationCountRequest
*/
func (a *AuthorizationAPIService) GetAuthorizationCount(ctx context.Context) ApiGetAuthorizationCountRequest {
	return ApiGetAuthorizationCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *AuthorizationAPIService) GetAuthorizationCountExecute(r ApiGetAuthorizationCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.GetAuthorizationCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorization/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.userIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userIdIn", r.userIdIn, "")
	}
	if r.groupIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupIdIn", r.groupIdIn, "")
	}
	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceType", r.resourceType, "")
	}
	if r.resourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceId", r.resourceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIsUserAuthorizedRequest struct {
	ctx context.Context
	ApiService AuthorizationAPI
	permissionName *string
	resourceName *string
	resourceType *int32
	resourceId *string
	userId *string
}

// String value representing the permission name to check for.
func (r ApiIsUserAuthorizedRequest) PermissionName(permissionName string) ApiIsUserAuthorizedRequest {
	r.permissionName = &permissionName
	return r
}

// String value for the name of the resource to check permissions for.
func (r ApiIsUserAuthorizedRequest) ResourceName(resourceName string) ApiIsUserAuthorizedRequest {
	r.resourceName = &resourceName
	return r
}

// An integer representing the resource type to check permissions for. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
func (r ApiIsUserAuthorizedRequest) ResourceType(resourceType int32) ApiIsUserAuthorizedRequest {
	r.resourceType = &resourceType
	return r
}

// The id of the resource to check permissions for. If left blank, a check for global permissions on the resource is performed.
func (r ApiIsUserAuthorizedRequest) ResourceId(resourceId string) ApiIsUserAuthorizedRequest {
	r.resourceId = &resourceId
	return r
}

// The id of the user to check permissions for. The currently authenticated user must have a READ permission for the Authorization resource. If &#x60;userId&#x60; is blank, a check for the currently authenticated user is performed.
func (r ApiIsUserAuthorizedRequest) UserId(userId string) ApiIsUserAuthorizedRequest {
	r.userId = &userId
	return r
}

func (r ApiIsUserAuthorizedRequest) Execute() (*AuthorizationCheckResultDto, *http.Response, error) {
	return r.ApiService.IsUserAuthorizedExecute(r)
}

/*
IsUserAuthorized Perform an Authorization Check

Performs an authorization check for the currently authenticated user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIsUserAuthorizedRequest
*/
func (a *AuthorizationAPIService) IsUserAuthorized(ctx context.Context) ApiIsUserAuthorizedRequest {
	return ApiIsUserAuthorizedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthorizationCheckResultDto
func (a *AuthorizationAPIService) IsUserAuthorizedExecute(r ApiIsUserAuthorizedRequest) (*AuthorizationCheckResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationCheckResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.IsUserAuthorized")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorization/check"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.permissionName == nil {
		return localVarReturnValue, nil, reportError("permissionName is required and must be specified")
	}
	if r.resourceName == nil {
		return localVarReturnValue, nil, reportError("resourceName is required and must be specified")
	}
	if r.resourceType == nil {
		return localVarReturnValue, nil, reportError("resourceType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionName", r.permissionName, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "resourceType", r.resourceType, "")
	if r.resourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceId", r.resourceId, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryAuthorizationsRequest struct {
	ctx context.Context
	ApiService AuthorizationAPI
	id *string
	type_ *int32
	userIdIn *string
	groupIdIn *string
	resourceType *int32
	resourceId *string
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Filter by the id of the authorization.
func (r ApiQueryAuthorizationsRequest) Id(id string) ApiQueryAuthorizationsRequest {
	r.id = &id
	return r
}

// Filter by authorization type. (0&#x3D;global, 1&#x3D;grant, 2&#x3D;revoke). See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/authorization-service/#authorization-type) for more information about authorization types.
func (r ApiQueryAuthorizationsRequest) Type_(type_ int32) ApiQueryAuthorizationsRequest {
	r.type_ = &type_
	return r
}

// Filter by a comma-separated list of userIds.
func (r ApiQueryAuthorizationsRequest) UserIdIn(userIdIn string) ApiQueryAuthorizationsRequest {
	r.userIdIn = &userIdIn
	return r
}

// Filter by a comma-separated list of groupIds.
func (r ApiQueryAuthorizationsRequest) GroupIdIn(groupIdIn string) ApiQueryAuthorizationsRequest {
	r.groupIdIn = &groupIdIn
	return r
}

// Filter by an integer representation of the resource type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/authorization-service/#resources) for a list of integer representations of resource types.
func (r ApiQueryAuthorizationsRequest) ResourceType(resourceType int32) ApiQueryAuthorizationsRequest {
	r.resourceType = &resourceType
	return r
}

// Filter by resource id.
func (r ApiQueryAuthorizationsRequest) ResourceId(resourceId string) ApiQueryAuthorizationsRequest {
	r.resourceId = &resourceId
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiQueryAuthorizationsRequest) SortBy(sortBy string) ApiQueryAuthorizationsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiQueryAuthorizationsRequest) SortOrder(sortOrder string) ApiQueryAuthorizationsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryAuthorizationsRequest) FirstResult(firstResult int32) ApiQueryAuthorizationsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryAuthorizationsRequest) MaxResults(maxResults int32) ApiQueryAuthorizationsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiQueryAuthorizationsRequest) Execute() ([]AuthorizationDto, *http.Response, error) {
	return r.ApiService.QueryAuthorizationsExecute(r)
}

/*
QueryAuthorizations Get Authorizations

Queries for a list of authorizations using a list of parameters.
The size of the result set can be retrieved by using the
[Get Authorization Count](https://docs.camunda.org/manual/7.21/reference/rest/authorization/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryAuthorizationsRequest
*/
func (a *AuthorizationAPIService) QueryAuthorizations(ctx context.Context) ApiQueryAuthorizationsRequest {
	return ApiQueryAuthorizationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AuthorizationDto
func (a *AuthorizationAPIService) QueryAuthorizationsExecute(r ApiQueryAuthorizationsRequest) ([]AuthorizationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AuthorizationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.QueryAuthorizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.userIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userIdIn", r.userIdIn, "")
	}
	if r.groupIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupIdIn", r.groupIdIn, "")
	}
	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceType", r.resourceType, "")
	}
	if r.resourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceId", r.resourceId, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthorizationRequest struct {
	ctx context.Context
	ApiService AuthorizationAPI
	id string
	authorizationUpdateDto *AuthorizationUpdateDto
}

func (r ApiUpdateAuthorizationRequest) AuthorizationUpdateDto(authorizationUpdateDto AuthorizationUpdateDto) ApiUpdateAuthorizationRequest {
	r.authorizationUpdateDto = &authorizationUpdateDto
	return r
}

func (r ApiUpdateAuthorizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAuthorizationExecute(r)
}

/*
UpdateAuthorization Update an Authorization

Updates an authorization by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the authorization to be updated.
 @return ApiUpdateAuthorizationRequest
*/
func (a *AuthorizationAPIService) UpdateAuthorization(ctx context.Context, id string) ApiUpdateAuthorizationRequest {
	return ApiUpdateAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AuthorizationAPIService) UpdateAuthorizationExecute(r ApiUpdateAuthorizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.UpdateAuthorization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorization/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationUpdateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
