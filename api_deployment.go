/*
Camunda Platform REST API

OpenApi Spec for Camunda Platform REST API.

API version: 7.21.2-ee
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package camundarestgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"os"
)


type DeploymentAPI interface {

	/*
	CreateDeployment Create

	Creates a deployment.

**Security Consideration**

Deployments can contain custom code in form of scripts or EL expressions to customize process behavior.
This may be abused for remote execution of arbitrary code.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDeploymentRequest
	*/
	CreateDeployment(ctx context.Context) ApiCreateDeploymentRequest

	// CreateDeploymentExecute executes the request
	//  @return DeploymentWithDefinitionsDto
	CreateDeploymentExecute(r ApiCreateDeploymentRequest) (*DeploymentWithDefinitionsDto, *http.Response, error)

	/*
	DeleteDeployment Delete

	Deletes a deployment by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the deployment to be deleted.
	@return ApiDeleteDeploymentRequest
	*/
	DeleteDeployment(ctx context.Context, id string) ApiDeleteDeploymentRequest

	// DeleteDeploymentExecute executes the request
	DeleteDeploymentExecute(r ApiDeleteDeploymentRequest) (*http.Response, error)

	/*
	GetDeployment Get

	Retrieves a deployment by id, according to the `Deployment` interface of the engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the deployment.
	@return ApiGetDeploymentRequest
	*/
	GetDeployment(ctx context.Context, id string) ApiGetDeploymentRequest

	// GetDeploymentExecute executes the request
	//  @return DeploymentDto
	GetDeploymentExecute(r ApiGetDeploymentRequest) (*DeploymentDto, *http.Response, error)

	/*
	GetDeploymentResource Get Resource

	Retrieves a deployment resource by resource id for the given deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the deployment
	@param resourceId The id of the deployment resource
	@return ApiGetDeploymentResourceRequest
	*/
	GetDeploymentResource(ctx context.Context, id string, resourceId string) ApiGetDeploymentResourceRequest

	// GetDeploymentResourceExecute executes the request
	//  @return DeploymentResourceDto
	GetDeploymentResourceExecute(r ApiGetDeploymentResourceRequest) (*DeploymentResourceDto, *http.Response, error)

	/*
	GetDeploymentResourceData Get Resource (Binary)

	Retrieves the binary content of a deployment resource for the given deployment by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the deployment.
	@param resourceId The id of the deployment resource.
	@return ApiGetDeploymentResourceDataRequest
	*/
	GetDeploymentResourceData(ctx context.Context, id string, resourceId string) ApiGetDeploymentResourceDataRequest

	// GetDeploymentResourceDataExecute executes the request
	//  @return *os.File
	GetDeploymentResourceDataExecute(r ApiGetDeploymentResourceDataRequest) (*os.File, *http.Response, error)

	/*
	GetDeploymentResources Get Resources

	Retrieves all deployment resources of a given deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the deployment to retrieve the deployment resources for.
	@return ApiGetDeploymentResourcesRequest
	*/
	GetDeploymentResources(ctx context.Context, id string) ApiGetDeploymentResourcesRequest

	// GetDeploymentResourcesExecute executes the request
	//  @return []DeploymentResourceDto
	GetDeploymentResourcesExecute(r ApiGetDeploymentResourcesRequest) ([]DeploymentResourceDto, *http.Response, error)

	/*
	GetDeployments Get List

	Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments,
such as the id or name or a range of the deployment time. The size of the result set can be retrieved by
using the [Get Deployment count](https://docs.camunda.org/manual/7.21/reference/rest/deployment/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDeploymentsRequest
	*/
	GetDeployments(ctx context.Context) ApiGetDeploymentsRequest

	// GetDeploymentsExecute executes the request
	//  @return []DeploymentDto
	GetDeploymentsExecute(r ApiGetDeploymentsRequest) ([]DeploymentDto, *http.Response, error)

	/*
	GetDeploymentsCount Get List Count

	Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the
[Get Deployments](https://docs.camunda.org/manual/7.21/reference/rest/deployment/get-query/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDeploymentsCountRequest
	*/
	GetDeploymentsCount(ctx context.Context) ApiGetDeploymentsCountRequest

	// GetDeploymentsCountExecute executes the request
	//  @return CountResultDto
	GetDeploymentsCountExecute(r ApiGetDeploymentsCountRequest) (*CountResultDto, *http.Response, error)

	/*
	GetRegisteredDeployments Get Registered Deployments

	Queries the registered deployment IDs for the current application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRegisteredDeploymentsRequest
	*/
	GetRegisteredDeployments(ctx context.Context) ApiGetRegisteredDeploymentsRequest

	// GetRegisteredDeploymentsExecute executes the request
	//  @return []string
	GetRegisteredDeploymentsExecute(r ApiGetRegisteredDeploymentsRequest) ([]string, *http.Response, error)

	/*
	Redeploy Redeploy

	Re-deploys an existing deployment.

The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or
`resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the
given deployment are re-deployed.

**Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize
process behavior. This may be abused for remote execution of arbitrary code. See the section on
[security considerations for custom code](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/) in
the user guide for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the deployment to re-deploy.
	@return ApiRedeployRequest
	*/
	Redeploy(ctx context.Context, id string) ApiRedeployRequest

	// RedeployExecute executes the request
	//  @return DeploymentWithDefinitionsDto
	RedeployExecute(r ApiRedeployRequest) (*DeploymentWithDefinitionsDto, *http.Response, error)
}

// DeploymentAPIService DeploymentAPI service
type DeploymentAPIService service

type ApiCreateDeploymentRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
	tenantId *string
	deploymentSource *string
	deployChangedOnly *bool
	enableDuplicateFiltering *bool
	deploymentName *string
	deploymentActivationTime *time.Time
	data *os.File
}

// The tenant id for the deployment to be created.
func (r ApiCreateDeploymentRequest) TenantId(tenantId string) ApiCreateDeploymentRequest {
	r.tenantId = &tenantId
	return r
}

// The source for the deployment to be created.
func (r ApiCreateDeploymentRequest) DeploymentSource(deploymentSource string) ApiCreateDeploymentRequest {
	r.deploymentSource = &deploymentSource
	return r
}

// A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
func (r ApiCreateDeploymentRequest) DeployChangedOnly(deployChangedOnly bool) ApiCreateDeploymentRequest {
	r.deployChangedOnly = &deployChangedOnly
	return r
}

// A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
func (r ApiCreateDeploymentRequest) EnableDuplicateFiltering(enableDuplicateFiltering bool) ApiCreateDeploymentRequest {
	r.enableDuplicateFiltering = &enableDuplicateFiltering
	return r
}

// The name for the deployment to be created.
func (r ApiCreateDeploymentRequest) DeploymentName(deploymentName string) ApiCreateDeploymentRequest {
	r.deploymentName = &deploymentName
	return r
}

// Sets the date on which the process definitions contained in this deployment will be activated. This means that all process definitions will be deployed as usual, but they will be suspended from the start until the given activation date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiCreateDeploymentRequest) DeploymentActivationTime(deploymentActivationTime time.Time) ApiCreateDeploymentRequest {
	r.deploymentActivationTime = &deploymentActivationTime
	return r
}

// The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
func (r ApiCreateDeploymentRequest) Data(data *os.File) ApiCreateDeploymentRequest {
	r.data = data
	return r
}

func (r ApiCreateDeploymentRequest) Execute() (*DeploymentWithDefinitionsDto, *http.Response, error) {
	return r.ApiService.CreateDeploymentExecute(r)
}

/*
CreateDeployment Create

Creates a deployment.

**Security Consideration**

Deployments can contain custom code in form of scripts or EL expressions to customize process behavior.
This may be abused for remote execution of arbitrary code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDeploymentRequest
*/
func (a *DeploymentAPIService) CreateDeployment(ctx context.Context) ApiCreateDeploymentRequest {
	return ApiCreateDeploymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeploymentWithDefinitionsDto
func (a *DeploymentAPIService) CreateDeploymentExecute(r ApiCreateDeploymentRequest) (*DeploymentWithDefinitionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentWithDefinitionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.CreateDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tenant-id", r.tenantId, "")
	}
	if r.deploymentSource != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "deployment-source", r.deploymentSource, "")
	}
	if r.deployChangedOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "deploy-changed-only", r.deployChangedOnly, "")
	}
	if r.enableDuplicateFiltering != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable-duplicate-filtering", r.enableDuplicateFiltering, "")
	}
	if r.deploymentName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "deployment-name", r.deploymentName, "")
	}
	if r.deploymentActivationTime != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "deployment-activation-time", r.deploymentActivationTime, "")
	}
	var dataLocalVarFormFileName string
	var dataLocalVarFileName     string
	var dataLocalVarFileBytes    []byte

	dataLocalVarFormFileName = "data"
	dataLocalVarFile := r.data

	if dataLocalVarFile != nil {
		fbs, _ := io.ReadAll(dataLocalVarFile)

		dataLocalVarFileBytes = fbs
		dataLocalVarFileName = dataLocalVarFile.Name()
		dataLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: dataLocalVarFileBytes, fileName: dataLocalVarFileName, formFileName: dataLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ParseExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDeploymentRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
	id string
	cascade *bool
	skipCustomListeners *bool
	skipIoMappings *bool
}

// &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
func (r ApiDeleteDeploymentRequest) Cascade(cascade bool) ApiDeleteDeploymentRequest {
	r.cascade = &cascade
	return r
}

// &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
func (r ApiDeleteDeploymentRequest) SkipCustomListeners(skipCustomListeners bool) ApiDeleteDeploymentRequest {
	r.skipCustomListeners = &skipCustomListeners
	return r
}

// &#x60;true&#x60;, if all input/output mappings should not be invoked.
func (r ApiDeleteDeploymentRequest) SkipIoMappings(skipIoMappings bool) ApiDeleteDeploymentRequest {
	r.skipIoMappings = &skipIoMappings
	return r
}

func (r ApiDeleteDeploymentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDeploymentExecute(r)
}

/*
DeleteDeployment Delete

Deletes a deployment by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the deployment to be deleted.
 @return ApiDeleteDeploymentRequest
*/
func (a *DeploymentAPIService) DeleteDeployment(ctx context.Context, id string) ApiDeleteDeploymentRequest {
	return ApiDeleteDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DeleteDeploymentExecute(r ApiDeleteDeploymentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DeleteDeployment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cascade != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cascade", r.cascade, "")
	} else {
		var defaultValue bool = false
		r.cascade = &defaultValue
	}
	if r.skipCustomListeners != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipCustomListeners", r.skipCustomListeners, "")
	} else {
		var defaultValue bool = false
		r.skipCustomListeners = &defaultValue
	}
	if r.skipIoMappings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipIoMappings", r.skipIoMappings, "")
	} else {
		var defaultValue bool = false
		r.skipIoMappings = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeploymentRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
	id string
}

func (r ApiGetDeploymentRequest) Execute() (*DeploymentDto, *http.Response, error) {
	return r.ApiService.GetDeploymentExecute(r)
}

/*
GetDeployment Get

Retrieves a deployment by id, according to the `Deployment` interface of the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the deployment.
 @return ApiGetDeploymentRequest
*/
func (a *DeploymentAPIService) GetDeployment(ctx context.Context, id string) ApiGetDeploymentRequest {
	return ApiGetDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeploymentDto
func (a *DeploymentAPIService) GetDeploymentExecute(r ApiGetDeploymentRequest) (*DeploymentDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeploymentResourceRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
	id string
	resourceId string
}

func (r ApiGetDeploymentResourceRequest) Execute() (*DeploymentResourceDto, *http.Response, error) {
	return r.ApiService.GetDeploymentResourceExecute(r)
}

/*
GetDeploymentResource Get Resource

Retrieves a deployment resource by resource id for the given deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the deployment
 @param resourceId The id of the deployment resource
 @return ApiGetDeploymentResourceRequest
*/
func (a *DeploymentAPIService) GetDeploymentResource(ctx context.Context, id string, resourceId string) ApiGetDeploymentResourceRequest {
	return ApiGetDeploymentResourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		resourceId: resourceId,
	}
}

// Execute executes the request
//  @return DeploymentResourceDto
func (a *DeploymentAPIService) GetDeploymentResourceExecute(r ApiGetDeploymentResourceRequest) (*DeploymentResourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentResourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetDeploymentResource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/{id}/resources/{resourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resourceId"+"}", url.PathEscape(parameterValueToString(r.resourceId, "resourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeploymentResourceDataRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
	id string
	resourceId string
}

func (r ApiGetDeploymentResourceDataRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDeploymentResourceDataExecute(r)
}

/*
GetDeploymentResourceData Get Resource (Binary)

Retrieves the binary content of a deployment resource for the given deployment by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the deployment.
 @param resourceId The id of the deployment resource.
 @return ApiGetDeploymentResourceDataRequest
*/
func (a *DeploymentAPIService) GetDeploymentResourceData(ctx context.Context, id string, resourceId string) ApiGetDeploymentResourceDataRequest {
	return ApiGetDeploymentResourceDataRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		resourceId: resourceId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DeploymentAPIService) GetDeploymentResourceDataExecute(r ApiGetDeploymentResourceDataRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetDeploymentResourceData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/{id}/resources/{resourceId}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resourceId"+"}", url.PathEscape(parameterValueToString(r.resourceId, "resourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeploymentResourcesRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
	id string
}

func (r ApiGetDeploymentResourcesRequest) Execute() ([]DeploymentResourceDto, *http.Response, error) {
	return r.ApiService.GetDeploymentResourcesExecute(r)
}

/*
GetDeploymentResources Get Resources

Retrieves all deployment resources of a given deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the deployment to retrieve the deployment resources for.
 @return ApiGetDeploymentResourcesRequest
*/
func (a *DeploymentAPIService) GetDeploymentResources(ctx context.Context, id string) ApiGetDeploymentResourcesRequest {
	return ApiGetDeploymentResourcesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []DeploymentResourceDto
func (a *DeploymentAPIService) GetDeploymentResourcesExecute(r ApiGetDeploymentResourcesRequest) ([]DeploymentResourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeploymentResourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetDeploymentResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/{id}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeploymentsRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
	id *string
	name *string
	nameLike *string
	source *string
	withoutSource *bool
	tenantIdIn *string
	withoutTenantId *bool
	includeDeploymentsWithoutTenantId *bool
	after *time.Time
	before *time.Time
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Filter by deployment id
func (r ApiGetDeploymentsRequest) Id(id string) ApiGetDeploymentsRequest {
	r.id = &id
	return r
}

// Filter by the deployment name. Exact match.
func (r ApiGetDeploymentsRequest) Name(name string) ApiGetDeploymentsRequest {
	r.name = &name
	return r
}

// Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
func (r ApiGetDeploymentsRequest) NameLike(nameLike string) ApiGetDeploymentsRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the deployment source.
func (r ApiGetDeploymentsRequest) Source(source string) ApiGetDeploymentsRequest {
	r.source = &source
	return r
}

// Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
func (r ApiGetDeploymentsRequest) WithoutSource(withoutSource bool) ApiGetDeploymentsRequest {
	r.withoutSource = &withoutSource
	return r
}

// Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
func (r ApiGetDeploymentsRequest) TenantIdIn(tenantIdIn string) ApiGetDeploymentsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDeploymentsRequest) WithoutTenantId(withoutTenantId bool) ApiGetDeploymentsRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDeploymentsRequest) IncludeDeploymentsWithoutTenantId(includeDeploymentsWithoutTenantId bool) ApiGetDeploymentsRequest {
	r.includeDeploymentsWithoutTenantId = &includeDeploymentsWithoutTenantId
	return r
}

// Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetDeploymentsRequest) After(after time.Time) ApiGetDeploymentsRequest {
	r.after = &after
	return r
}

// Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetDeploymentsRequest) Before(before time.Time) ApiGetDeploymentsRequest {
	r.before = &before
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetDeploymentsRequest) SortBy(sortBy string) ApiGetDeploymentsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetDeploymentsRequest) SortOrder(sortOrder string) ApiGetDeploymentsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetDeploymentsRequest) FirstResult(firstResult int32) ApiGetDeploymentsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetDeploymentsRequest) MaxResults(maxResults int32) ApiGetDeploymentsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetDeploymentsRequest) Execute() ([]DeploymentDto, *http.Response, error) {
	return r.ApiService.GetDeploymentsExecute(r)
}

/*
GetDeployments Get List

Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments,
such as the id or name or a range of the deployment time. The size of the result set can be retrieved by
using the [Get Deployment count](https://docs.camunda.org/manual/7.21/reference/rest/deployment/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDeploymentsRequest
*/
func (a *DeploymentAPIService) GetDeployments(ctx context.Context) ApiGetDeploymentsRequest {
	return ApiGetDeploymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeploymentDto
func (a *DeploymentAPIService) GetDeploymentsExecute(r ApiGetDeploymentsRequest) ([]DeploymentDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeploymentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetDeployments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "")
	}
	if r.withoutSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutSource", r.withoutSource, "")
	} else {
		var defaultValue bool = false
		r.withoutSource = &defaultValue
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	} else {
		var defaultValue bool = false
		r.withoutTenantId = &defaultValue
	}
	if r.includeDeploymentsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeploymentsWithoutTenantId", r.includeDeploymentsWithoutTenantId, "")
	} else {
		var defaultValue bool = false
		r.includeDeploymentsWithoutTenantId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeploymentsCountRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
	id *string
	name *string
	nameLike *string
	source *string
	withoutSource *bool
	tenantIdIn *string
	withoutTenantId *bool
	includeDeploymentsWithoutTenantId *bool
	after *time.Time
	before *time.Time
}

// Filter by deployment id
func (r ApiGetDeploymentsCountRequest) Id(id string) ApiGetDeploymentsCountRequest {
	r.id = &id
	return r
}

// Filter by the deployment name. Exact match.
func (r ApiGetDeploymentsCountRequest) Name(name string) ApiGetDeploymentsCountRequest {
	r.name = &name
	return r
}

// Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
func (r ApiGetDeploymentsCountRequest) NameLike(nameLike string) ApiGetDeploymentsCountRequest {
	r.nameLike = &nameLike
	return r
}

// Filter by the deployment source.
func (r ApiGetDeploymentsCountRequest) Source(source string) ApiGetDeploymentsCountRequest {
	r.source = &source
	return r
}

// Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
func (r ApiGetDeploymentsCountRequest) WithoutSource(withoutSource bool) ApiGetDeploymentsCountRequest {
	r.withoutSource = &withoutSource
	return r
}

// Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
func (r ApiGetDeploymentsCountRequest) TenantIdIn(tenantIdIn string) ApiGetDeploymentsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDeploymentsCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetDeploymentsCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetDeploymentsCountRequest) IncludeDeploymentsWithoutTenantId(includeDeploymentsWithoutTenantId bool) ApiGetDeploymentsCountRequest {
	r.includeDeploymentsWithoutTenantId = &includeDeploymentsWithoutTenantId
	return r
}

// Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetDeploymentsCountRequest) After(after time.Time) ApiGetDeploymentsCountRequest {
	r.after = &after
	return r
}

// Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetDeploymentsCountRequest) Before(before time.Time) ApiGetDeploymentsCountRequest {
	r.before = &before
	return r
}

func (r ApiGetDeploymentsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetDeploymentsCountExecute(r)
}

/*
GetDeploymentsCount Get List Count

Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the
[Get Deployments](https://docs.camunda.org/manual/7.21/reference/rest/deployment/get-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDeploymentsCountRequest
*/
func (a *DeploymentAPIService) GetDeploymentsCount(ctx context.Context) ApiGetDeploymentsCountRequest {
	return ApiGetDeploymentsCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *DeploymentAPIService) GetDeploymentsCountExecute(r ApiGetDeploymentsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetDeploymentsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "")
	}
	if r.withoutSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutSource", r.withoutSource, "")
	} else {
		var defaultValue bool = false
		r.withoutSource = &defaultValue
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	} else {
		var defaultValue bool = false
		r.withoutTenantId = &defaultValue
	}
	if r.includeDeploymentsWithoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeploymentsWithoutTenantId", r.includeDeploymentsWithoutTenantId, "")
	} else {
		var defaultValue bool = false
		r.includeDeploymentsWithoutTenantId = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRegisteredDeploymentsRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
}

func (r ApiGetRegisteredDeploymentsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetRegisteredDeploymentsExecute(r)
}

/*
GetRegisteredDeployments Get Registered Deployments

Queries the registered deployment IDs for the current application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRegisteredDeploymentsRequest
*/
func (a *DeploymentAPIService) GetRegisteredDeployments(ctx context.Context) ApiGetRegisteredDeploymentsRequest {
	return ApiGetRegisteredDeploymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *DeploymentAPIService) GetRegisteredDeploymentsExecute(r ApiGetRegisteredDeploymentsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetRegisteredDeployments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/registered"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRedeployRequest struct {
	ctx context.Context
	ApiService DeploymentAPI
	id string
	redeploymentDto *RedeploymentDto
}

func (r ApiRedeployRequest) RedeploymentDto(redeploymentDto RedeploymentDto) ApiRedeployRequest {
	r.redeploymentDto = &redeploymentDto
	return r
}

func (r ApiRedeployRequest) Execute() (*DeploymentWithDefinitionsDto, *http.Response, error) {
	return r.ApiService.RedeployExecute(r)
}

/*
Redeploy Redeploy

Re-deploys an existing deployment.

The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or
`resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the
given deployment are re-deployed.

**Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize
process behavior. This may be abused for remote execution of arbitrary code. See the section on
[security considerations for custom code](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/) in
the user guide for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the deployment to re-deploy.
 @return ApiRedeployRequest
*/
func (a *DeploymentAPIService) Redeploy(ctx context.Context, id string) ApiRedeployRequest {
	return ApiRedeployRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeploymentWithDefinitionsDto
func (a *DeploymentAPIService) RedeployExecute(r ApiRedeployRequest) (*DeploymentWithDefinitionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentWithDefinitionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.Redeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/{id}/redeploy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.redeploymentDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
