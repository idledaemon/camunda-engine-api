/*
Camunda Platform REST API

OpenApi Spec for Camunda Platform REST API.

API version: 7.21.2-ee
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package camundarestgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type TenantAPI interface {

	/*
	AvailableTenantGroupMembersOperations Tenant Group Membership Resource Options

	The OPTIONS request allows checking for the set of available operations that the
currently authenticated user can perform on the resource. If the user
can perform an operation or not may depend on various things,
including the users authorizations to interact with this resource and
the internal configuration of the process engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant
	@return ApiAvailableTenantGroupMembersOperationsRequest
	*/
	AvailableTenantGroupMembersOperations(ctx context.Context, id string) ApiAvailableTenantGroupMembersOperationsRequest

	// AvailableTenantGroupMembersOperationsExecute executes the request
	//  @return ResourceOptionsDto
	AvailableTenantGroupMembersOperationsExecute(r ApiAvailableTenantGroupMembersOperationsRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	AvailableTenantInstanceOperations Tenant Resource Options

	The `/tenant` resource supports two custom OPTIONS requests, one for the resource as such and this one for
individual tenant instances. The OPTIONS request allows checking for the set of available operations that
the currently authenticated user can perform on the `/tenant/{id}` resource. If the user can perform an
operation or not may depend on various things, including the users authorizations to interact with this
resource and the internal configuration of the process engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant
	@return ApiAvailableTenantInstanceOperationsRequest
	*/
	AvailableTenantInstanceOperations(ctx context.Context, id string) ApiAvailableTenantInstanceOperationsRequest

	// AvailableTenantInstanceOperationsExecute executes the request
	//  @return ResourceOptionsDto
	AvailableTenantInstanceOperationsExecute(r ApiAvailableTenantInstanceOperationsRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	AvailableTenantResourceOperations Tenant Resource Options

	The `/tenant` resource supports two custom OPTIONS requests, this one for the resource
as such and one for individual tenant instances. The OPTIONS request
allows checking for the set of available operations that the currently
authenticated user can perform on the `/tenant` resource. If the user
can perform an operation or not may depend on various things,
including the users authorizations to interact with this resource and
the internal configuration of the process engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAvailableTenantResourceOperationsRequest
	*/
	AvailableTenantResourceOperations(ctx context.Context) ApiAvailableTenantResourceOperationsRequest

	// AvailableTenantResourceOperationsExecute executes the request
	//  @return ResourceOptionsDto
	AvailableTenantResourceOperationsExecute(r ApiAvailableTenantResourceOperationsRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	AvailableTenantUserMembersOperations Tenant User Membership Resource Options

	The OPTIONS request allows checking for the set of available operations that the
currently authenticated user can perform on the resource. If the user
can perform an operation or not may depend on various things,
including the users authorizations to interact with this resource and
the internal configuration of the process engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant
	@return ApiAvailableTenantUserMembersOperationsRequest
	*/
	AvailableTenantUserMembersOperations(ctx context.Context, id string) ApiAvailableTenantUserMembersOperationsRequest

	// AvailableTenantUserMembersOperationsExecute executes the request
	//  @return ResourceOptionsDto
	AvailableTenantUserMembersOperationsExecute(r ApiAvailableTenantUserMembersOperationsRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	CreateGroupMembership Create Tenant Group Membership

	Creates a membership between a tenant and a group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant.
	@param groupId The id of the group.
	@return ApiCreateGroupMembershipRequest
	*/
	CreateGroupMembership(ctx context.Context, id string, groupId string) ApiCreateGroupMembershipRequest

	// CreateGroupMembershipExecute executes the request
	CreateGroupMembershipExecute(r ApiCreateGroupMembershipRequest) (*http.Response, error)

	/*
	CreateTenant Create Tenant

	Create a new tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateTenantRequest
	*/
	CreateTenant(ctx context.Context) ApiCreateTenantRequest

	// CreateTenantExecute executes the request
	CreateTenantExecute(r ApiCreateTenantRequest) (*http.Response, error)

	/*
	CreateUserMembership Create Tenant User Membership

	Creates a membership between a tenant and an user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant.
	@param userId The id of the user.
	@return ApiCreateUserMembershipRequest
	*/
	CreateUserMembership(ctx context.Context, id string, userId string) ApiCreateUserMembershipRequest

	// CreateUserMembershipExecute executes the request
	CreateUserMembershipExecute(r ApiCreateUserMembershipRequest) (*http.Response, error)

	/*
	DeleteGroupMembership Create Tenant Group Membership

	Creates a membership between a tenant and a group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant.
	@param groupId The id of the group.
	@return ApiDeleteGroupMembershipRequest
	*/
	DeleteGroupMembership(ctx context.Context, id string, groupId string) ApiDeleteGroupMembershipRequest

	// DeleteGroupMembershipExecute executes the request
	DeleteGroupMembershipExecute(r ApiDeleteGroupMembershipRequest) (*http.Response, error)

	/*
	DeleteTenant Delete Tenant

	Deletes a tenant by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant to be deleted.
	@return ApiDeleteTenantRequest
	*/
	DeleteTenant(ctx context.Context, id string) ApiDeleteTenantRequest

	// DeleteTenantExecute executes the request
	DeleteTenantExecute(r ApiDeleteTenantRequest) (*http.Response, error)

	/*
	DeleteUserMembership Delete a Tenant User Membership

	Deletes a membership between a tenant and an user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant.
	@param userId The id of the user.
	@return ApiDeleteUserMembershipRequest
	*/
	DeleteUserMembership(ctx context.Context, id string, userId string) ApiDeleteUserMembershipRequest

	// DeleteUserMembershipExecute executes the request
	DeleteUserMembershipExecute(r ApiDeleteUserMembershipRequest) (*http.Response, error)

	/*
	GetTenant Get Tenant

	Retrieves a tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant to be retrieved.
	@return ApiGetTenantRequest
	*/
	GetTenant(ctx context.Context, id string) ApiGetTenantRequest

	// GetTenantExecute executes the request
	//  @return TenantDto
	GetTenantExecute(r ApiGetTenantRequest) (*TenantDto, *http.Response, error)

	/*
	GetTenantCount Get Tenant Count

	Query for tenants using a list of parameters and retrieves the count.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTenantCountRequest
	*/
	GetTenantCount(ctx context.Context) ApiGetTenantCountRequest

	// GetTenantCountExecute executes the request
	//  @return CountResultDto
	GetTenantCountExecute(r ApiGetTenantCountRequest) (*CountResultDto, *http.Response, error)

	/*
	QueryTenants Get Tenants

	Query for a list of tenants using a list of parameters. The size of the result set
can be retrieved by using the [Get Tenant
Count](https://docs.camunda.org/manual/7.21/reference/rest/tenant/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryTenantsRequest
	*/
	QueryTenants(ctx context.Context) ApiQueryTenantsRequest

	// QueryTenantsExecute executes the request
	//  @return []TenantDto
	QueryTenantsExecute(r ApiQueryTenantsRequest) ([]TenantDto, *http.Response, error)

	/*
	UpdateTenant Update Tenant

	Updates a given tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the tenant.
	@return ApiUpdateTenantRequest
	*/
	UpdateTenant(ctx context.Context, id string) ApiUpdateTenantRequest

	// UpdateTenantExecute executes the request
	UpdateTenantExecute(r ApiUpdateTenantRequest) (*http.Response, error)
}

// TenantAPIService TenantAPI service
type TenantAPIService service

type ApiAvailableTenantGroupMembersOperationsRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
}

func (r ApiAvailableTenantGroupMembersOperationsRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.AvailableTenantGroupMembersOperationsExecute(r)
}

/*
AvailableTenantGroupMembersOperations Tenant Group Membership Resource Options

The OPTIONS request allows checking for the set of available operations that the
currently authenticated user can perform on the resource. If the user
can perform an operation or not may depend on various things,
including the users authorizations to interact with this resource and
the internal configuration of the process engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant
 @return ApiAvailableTenantGroupMembersOperationsRequest
*/
func (a *TenantAPIService) AvailableTenantGroupMembersOperations(ctx context.Context, id string) ApiAvailableTenantGroupMembersOperationsRequest {
	return ApiAvailableTenantGroupMembersOperationsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *TenantAPIService) AvailableTenantGroupMembersOperationsExecute(r ApiAvailableTenantGroupMembersOperationsRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.AvailableTenantGroupMembersOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}/group-members"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAvailableTenantInstanceOperationsRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
}

func (r ApiAvailableTenantInstanceOperationsRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.AvailableTenantInstanceOperationsExecute(r)
}

/*
AvailableTenantInstanceOperations Tenant Resource Options

The `/tenant` resource supports two custom OPTIONS requests, one for the resource as such and this one for
individual tenant instances. The OPTIONS request allows checking for the set of available operations that
the currently authenticated user can perform on the `/tenant/{id}` resource. If the user can perform an
operation or not may depend on various things, including the users authorizations to interact with this
resource and the internal configuration of the process engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant
 @return ApiAvailableTenantInstanceOperationsRequest
*/
func (a *TenantAPIService) AvailableTenantInstanceOperations(ctx context.Context, id string) ApiAvailableTenantInstanceOperationsRequest {
	return ApiAvailableTenantInstanceOperationsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *TenantAPIService) AvailableTenantInstanceOperationsExecute(r ApiAvailableTenantInstanceOperationsRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.AvailableTenantInstanceOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAvailableTenantResourceOperationsRequest struct {
	ctx context.Context
	ApiService TenantAPI
}

func (r ApiAvailableTenantResourceOperationsRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.AvailableTenantResourceOperationsExecute(r)
}

/*
AvailableTenantResourceOperations Tenant Resource Options

The `/tenant` resource supports two custom OPTIONS requests, this one for the resource
as such and one for individual tenant instances. The OPTIONS request
allows checking for the set of available operations that the currently
authenticated user can perform on the `/tenant` resource. If the user
can perform an operation or not may depend on various things,
including the users authorizations to interact with this resource and
the internal configuration of the process engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAvailableTenantResourceOperationsRequest
*/
func (a *TenantAPIService) AvailableTenantResourceOperations(ctx context.Context) ApiAvailableTenantResourceOperationsRequest {
	return ApiAvailableTenantResourceOperationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *TenantAPIService) AvailableTenantResourceOperationsExecute(r ApiAvailableTenantResourceOperationsRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.AvailableTenantResourceOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAvailableTenantUserMembersOperationsRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
}

func (r ApiAvailableTenantUserMembersOperationsRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.AvailableTenantUserMembersOperationsExecute(r)
}

/*
AvailableTenantUserMembersOperations Tenant User Membership Resource Options

The OPTIONS request allows checking for the set of available operations that the
currently authenticated user can perform on the resource. If the user
can perform an operation or not may depend on various things,
including the users authorizations to interact with this resource and
the internal configuration of the process engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant
 @return ApiAvailableTenantUserMembersOperationsRequest
*/
func (a *TenantAPIService) AvailableTenantUserMembersOperations(ctx context.Context, id string) ApiAvailableTenantUserMembersOperationsRequest {
	return ApiAvailableTenantUserMembersOperationsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *TenantAPIService) AvailableTenantUserMembersOperationsExecute(r ApiAvailableTenantUserMembersOperationsRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.AvailableTenantUserMembersOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}/user-members"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGroupMembershipRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
	groupId string
}

func (r ApiCreateGroupMembershipRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateGroupMembershipExecute(r)
}

/*
CreateGroupMembership Create Tenant Group Membership

Creates a membership between a tenant and a group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant.
 @param groupId The id of the group.
 @return ApiCreateGroupMembershipRequest
*/
func (a *TenantAPIService) CreateGroupMembership(ctx context.Context, id string, groupId string) ApiCreateGroupMembershipRequest {
	return ApiCreateGroupMembershipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *TenantAPIService) CreateGroupMembershipExecute(r ApiCreateGroupMembershipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.CreateGroupMembership")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}/group-members/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateTenantRequest struct {
	ctx context.Context
	ApiService TenantAPI
	tenantDto *TenantDto
}

func (r ApiCreateTenantRequest) TenantDto(tenantDto TenantDto) ApiCreateTenantRequest {
	r.tenantDto = &tenantDto
	return r
}

func (r ApiCreateTenantRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateTenantExecute(r)
}

/*
CreateTenant Create Tenant

Create a new tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTenantRequest
*/
func (a *TenantAPIService) CreateTenant(ctx context.Context) ApiCreateTenantRequest {
	return ApiCreateTenantRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TenantAPIService) CreateTenantExecute(r ApiCreateTenantRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.CreateTenant")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tenantDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateUserMembershipRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
	userId string
}

func (r ApiCreateUserMembershipRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateUserMembershipExecute(r)
}

/*
CreateUserMembership Create Tenant User Membership

Creates a membership between a tenant and an user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant.
 @param userId The id of the user.
 @return ApiCreateUserMembershipRequest
*/
func (a *TenantAPIService) CreateUserMembership(ctx context.Context, id string, userId string) ApiCreateUserMembershipRequest {
	return ApiCreateUserMembershipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
func (a *TenantAPIService) CreateUserMembershipExecute(r ApiCreateUserMembershipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.CreateUserMembership")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}/user-members/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteGroupMembershipRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
	groupId string
}

func (r ApiDeleteGroupMembershipRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGroupMembershipExecute(r)
}

/*
DeleteGroupMembership Create Tenant Group Membership

Creates a membership between a tenant and a group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant.
 @param groupId The id of the group.
 @return ApiDeleteGroupMembershipRequest
*/
func (a *TenantAPIService) DeleteGroupMembership(ctx context.Context, id string, groupId string) ApiDeleteGroupMembershipRequest {
	return ApiDeleteGroupMembershipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *TenantAPIService) DeleteGroupMembershipExecute(r ApiDeleteGroupMembershipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.DeleteGroupMembership")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}/group-members/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTenantRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
}

func (r ApiDeleteTenantRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTenantExecute(r)
}

/*
DeleteTenant Delete Tenant

Deletes a tenant by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant to be deleted.
 @return ApiDeleteTenantRequest
*/
func (a *TenantAPIService) DeleteTenant(ctx context.Context, id string) ApiDeleteTenantRequest {
	return ApiDeleteTenantRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TenantAPIService) DeleteTenantExecute(r ApiDeleteTenantRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.DeleteTenant")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUserMembershipRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
	userId string
}

func (r ApiDeleteUserMembershipRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserMembershipExecute(r)
}

/*
DeleteUserMembership Delete a Tenant User Membership

Deletes a membership between a tenant and an user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant.
 @param userId The id of the user.
 @return ApiDeleteUserMembershipRequest
*/
func (a *TenantAPIService) DeleteUserMembership(ctx context.Context, id string, userId string) ApiDeleteUserMembershipRequest {
	return ApiDeleteUserMembershipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
func (a *TenantAPIService) DeleteUserMembershipExecute(r ApiDeleteUserMembershipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.DeleteUserMembership")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}/user-members/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetTenantRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
}

func (r ApiGetTenantRequest) Execute() (*TenantDto, *http.Response, error) {
	return r.ApiService.GetTenantExecute(r)
}

/*
GetTenant Get Tenant

Retrieves a tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant to be retrieved.
 @return ApiGetTenantRequest
*/
func (a *TenantAPIService) GetTenant(ctx context.Context, id string) ApiGetTenantRequest {
	return ApiGetTenantRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TenantDto
func (a *TenantAPIService) GetTenantExecute(r ApiGetTenantRequest) (*TenantDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.GetTenant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTenantCountRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id *string
	name *string
	nameLike *string
	userMember *string
	groupMember *string
	includingGroupsOfUser *bool
}

// Filter by the id of the tenant.
func (r ApiGetTenantCountRequest) Id(id string) ApiGetTenantCountRequest {
	r.id = &id
	return r
}

// Filter by the name of the tenant.
func (r ApiGetTenantCountRequest) Name(name string) ApiGetTenantCountRequest {
	r.name = &name
	return r
}

// Filter by the name that the parameter is a substring of.
func (r ApiGetTenantCountRequest) NameLike(nameLike string) ApiGetTenantCountRequest {
	r.nameLike = &nameLike
	return r
}

// Select only tenants where the given user is a member of.
func (r ApiGetTenantCountRequest) UserMember(userMember string) ApiGetTenantCountRequest {
	r.userMember = &userMember
	return r
}

// Select only tenants where the given group is a member of.
func (r ApiGetTenantCountRequest) GroupMember(groupMember string) ApiGetTenantCountRequest {
	r.groupMember = &groupMember
	return r
}

// Select only tenants where the user or one of his groups is a member of. Can only be used in combination with the &#x60;userMember&#x60; parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTenantCountRequest) IncludingGroupsOfUser(includingGroupsOfUser bool) ApiGetTenantCountRequest {
	r.includingGroupsOfUser = &includingGroupsOfUser
	return r
}

func (r ApiGetTenantCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetTenantCountExecute(r)
}

/*
GetTenantCount Get Tenant Count

Query for tenants using a list of parameters and retrieves the count.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTenantCountRequest
*/
func (a *TenantAPIService) GetTenantCount(ctx context.Context) ApiGetTenantCountRequest {
	return ApiGetTenantCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *TenantAPIService) GetTenantCountExecute(r ApiGetTenantCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.GetTenantCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.userMember != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userMember", r.userMember, "")
	}
	if r.groupMember != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupMember", r.groupMember, "")
	}
	if r.includingGroupsOfUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includingGroupsOfUser", r.includingGroupsOfUser, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryTenantsRequest struct {
	ctx context.Context
	ApiService TenantAPI
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
	id *string
	name *string
	nameLike *string
	userMember *string
	groupMember *string
	includingGroupsOfUser *bool
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiQueryTenantsRequest) SortBy(sortBy string) ApiQueryTenantsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiQueryTenantsRequest) SortOrder(sortOrder string) ApiQueryTenantsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryTenantsRequest) FirstResult(firstResult int32) ApiQueryTenantsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryTenantsRequest) MaxResults(maxResults int32) ApiQueryTenantsRequest {
	r.maxResults = &maxResults
	return r
}

// Filter by the id of the tenant.
func (r ApiQueryTenantsRequest) Id(id string) ApiQueryTenantsRequest {
	r.id = &id
	return r
}

// Filter by the name of the tenant.
func (r ApiQueryTenantsRequest) Name(name string) ApiQueryTenantsRequest {
	r.name = &name
	return r
}

// Filter by the name that the parameter is a substring of.
func (r ApiQueryTenantsRequest) NameLike(nameLike string) ApiQueryTenantsRequest {
	r.nameLike = &nameLike
	return r
}

// Select only tenants where the given user is a member of.
func (r ApiQueryTenantsRequest) UserMember(userMember string) ApiQueryTenantsRequest {
	r.userMember = &userMember
	return r
}

// Select only tenants where the given group is a member of.
func (r ApiQueryTenantsRequest) GroupMember(groupMember string) ApiQueryTenantsRequest {
	r.groupMember = &groupMember
	return r
}

// Select only tenants where the user or one of his groups is a member of. Can only be used in combination with the &#x60;userMember&#x60; parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiQueryTenantsRequest) IncludingGroupsOfUser(includingGroupsOfUser bool) ApiQueryTenantsRequest {
	r.includingGroupsOfUser = &includingGroupsOfUser
	return r
}

func (r ApiQueryTenantsRequest) Execute() ([]TenantDto, *http.Response, error) {
	return r.ApiService.QueryTenantsExecute(r)
}

/*
QueryTenants Get Tenants

Query for a list of tenants using a list of parameters. The size of the result set
can be retrieved by using the [Get Tenant
Count](https://docs.camunda.org/manual/7.21/reference/rest/tenant/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryTenantsRequest
*/
func (a *TenantAPIService) QueryTenants(ctx context.Context) ApiQueryTenantsRequest {
	return ApiQueryTenantsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TenantDto
func (a *TenantAPIService) QueryTenantsExecute(r ApiQueryTenantsRequest) ([]TenantDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TenantDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.QueryTenants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.userMember != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userMember", r.userMember, "")
	}
	if r.groupMember != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupMember", r.groupMember, "")
	}
	if r.includingGroupsOfUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includingGroupsOfUser", r.includingGroupsOfUser, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTenantRequest struct {
	ctx context.Context
	ApiService TenantAPI
	id string
	tenantDto *TenantDto
}

func (r ApiUpdateTenantRequest) TenantDto(tenantDto TenantDto) ApiUpdateTenantRequest {
	r.tenantDto = &tenantDto
	return r
}

func (r ApiUpdateTenantRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateTenantExecute(r)
}

/*
UpdateTenant Update Tenant

Updates a given tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the tenant.
 @return ApiUpdateTenantRequest
*/
func (a *TenantAPIService) UpdateTenant(ctx context.Context, id string) ApiUpdateTenantRequest {
	return ApiUpdateTenantRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TenantAPIService) UpdateTenantExecute(r ApiUpdateTenantRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAPIService.UpdateTenant")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tenant/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tenantDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
