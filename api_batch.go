/*
Camunda Platform REST API

OpenApi Spec for Camunda Platform REST API.

API version: 7.21.2-ee
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package camundarestgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


type BatchAPI interface {

	/*
	DeleteBatch Delete

	Deletes a batch by id, including all related jobs and job definitions.
Optionally also deletes the batch history.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the batch to be deleted.
	@return ApiDeleteBatchRequest
	*/
	DeleteBatch(ctx context.Context, id string) ApiDeleteBatchRequest

	// DeleteBatchExecute executes the request
	DeleteBatchExecute(r ApiDeleteBatchRequest) (*http.Response, error)

	/*
	GetBatch Get

	Retrieves a batch by id, according to the Batch interface in the engine.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the batch to be retrieved.
	@return ApiGetBatchRequest
	*/
	GetBatch(ctx context.Context, id string) ApiGetBatchRequest

	// GetBatchExecute executes the request
	//  @return BatchDto
	GetBatchExecute(r ApiGetBatchRequest) (*BatchDto, *http.Response, error)

	/*
	GetBatchStatistics Get Statistics

	Queries for batch statistics that fulfill given parameters.
Parameters may be the properties of batches, such as the id or type.
The size of the result set can be retrieved by using the 
[Get Batch Statistics Count](https://docs.camunda.org/manual/7.21/reference/rest/batch/get-statistics-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBatchStatisticsRequest
	*/
	GetBatchStatistics(ctx context.Context) ApiGetBatchStatisticsRequest

	// GetBatchStatisticsExecute executes the request
	//  @return []BatchStatisticsDto
	GetBatchStatisticsExecute(r ApiGetBatchStatisticsRequest) ([]BatchStatisticsDto, *http.Response, error)

	/*
	GetBatchStatisticsCount Get Statistics Count

	Requests the number of batch statistics that fulfill the query criteria.
Takes the same filtering parameters as the
[Get Batch Statistics](https://docs.camunda.org/manual/7.21/reference/rest/batch/get-statistics-query/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBatchStatisticsCountRequest
	*/
	GetBatchStatisticsCount(ctx context.Context) ApiGetBatchStatisticsCountRequest

	// GetBatchStatisticsCountExecute executes the request
	//  @return CountResultDto
	GetBatchStatisticsCountExecute(r ApiGetBatchStatisticsCountRequest) (*CountResultDto, *http.Response, error)

	/*
	GetBatches Get List

	Queries for batches that fulfill given parameters. Parameters may be the properties of batches, such as the id or type.
The size of the result set can be retrieved by using the
[Get Batch Count](https://docs.camunda.org/manual/7.21/reference/rest/batch/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBatchesRequest
	*/
	GetBatches(ctx context.Context) ApiGetBatchesRequest

	// GetBatchesExecute executes the request
	//  @return []BatchDto
	GetBatchesExecute(r ApiGetBatchesRequest) ([]BatchDto, *http.Response, error)

	/*
	GetBatchesCount Get List Count

	Requests the number of batches that fulfill the query criteria.
Takes the same filtering parameters as the [Get Batches](https://docs.camunda.org/manual/7.21/reference/rest/batch/get-query/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBatchesCountRequest
	*/
	GetBatchesCount(ctx context.Context) ApiGetBatchesCountRequest

	// GetBatchesCountExecute executes the request
	//  @return CountResultDto
	GetBatchesCountExecute(r ApiGetBatchesCountRequest) (*CountResultDto, *http.Response, error)

	/*
	UpdateBatchSuspensionState Activate/Suspend

	Activates or suspends a batch by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the batch to activate or suspend.
	@return ApiUpdateBatchSuspensionStateRequest
	*/
	UpdateBatchSuspensionState(ctx context.Context, id string) ApiUpdateBatchSuspensionStateRequest

	// UpdateBatchSuspensionStateExecute executes the request
	UpdateBatchSuspensionStateExecute(r ApiUpdateBatchSuspensionStateRequest) (*http.Response, error)
}

// BatchAPIService BatchAPI service
type BatchAPIService service

type ApiDeleteBatchRequest struct {
	ctx context.Context
	ApiService BatchAPI
	id string
	cascade *bool
}

// &#x60;true&#x60;, if the historic batch and historic job logs for this batch should also be deleted.
func (r ApiDeleteBatchRequest) Cascade(cascade bool) ApiDeleteBatchRequest {
	r.cascade = &cascade
	return r
}

func (r ApiDeleteBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBatchExecute(r)
}

/*
DeleteBatch Delete

Deletes a batch by id, including all related jobs and job definitions.
Optionally also deletes the batch history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the batch to be deleted.
 @return ApiDeleteBatchRequest
*/
func (a *BatchAPIService) DeleteBatch(ctx context.Context, id string) ApiDeleteBatchRequest {
	return ApiDeleteBatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *BatchAPIService) DeleteBatchExecute(r ApiDeleteBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.DeleteBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/batch/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cascade != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cascade", r.cascade, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBatchRequest struct {
	ctx context.Context
	ApiService BatchAPI
	id string
}

func (r ApiGetBatchRequest) Execute() (*BatchDto, *http.Response, error) {
	return r.ApiService.GetBatchExecute(r)
}

/*
GetBatch Get

Retrieves a batch by id, according to the Batch interface in the engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the batch to be retrieved.
 @return ApiGetBatchRequest
*/
func (a *BatchAPIService) GetBatch(ctx context.Context, id string) ApiGetBatchRequest {
	return ApiGetBatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BatchDto
func (a *BatchAPIService) GetBatchExecute(r ApiGetBatchRequest) (*BatchDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.GetBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/batch/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchStatisticsRequest struct {
	ctx context.Context
	ApiService BatchAPI
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
	batchId *string
	type_ *string
	tenantIdIn *string
	withoutTenantId *bool
	suspended *bool
	createdBy *string
	startedBefore *time.Time
	startedAfter *time.Time
	withFailures *bool
	withoutFailures *bool
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetBatchStatisticsRequest) SortBy(sortBy string) ApiGetBatchStatisticsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetBatchStatisticsRequest) SortOrder(sortOrder string) ApiGetBatchStatisticsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetBatchStatisticsRequest) FirstResult(firstResult int32) ApiGetBatchStatisticsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetBatchStatisticsRequest) MaxResults(maxResults int32) ApiGetBatchStatisticsRequest {
	r.maxResults = &maxResults
	return r
}

// Filter by batch id.
func (r ApiGetBatchStatisticsRequest) BatchId(batchId string) ApiGetBatchStatisticsRequest {
	r.batchId = &batchId
	return r
}

// Filter by batch type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/batch/#creating-a-batch) for more information about batch types.
func (r ApiGetBatchStatisticsRequest) Type_(type_ string) ApiGetBatchStatisticsRequest {
	r.type_ = &type_
	return r
}

// Filter by a comma-separated list of &#x60;Strings&#x60;. A batch matches if it has one of the given tenant ids.
func (r ApiGetBatchStatisticsRequest) TenantIdIn(tenantIdIn string) ApiGetBatchStatisticsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include batches which belong to no tenant. Value can effectively only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetBatchStatisticsRequest) WithoutTenantId(withoutTenantId bool) ApiGetBatchStatisticsRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// A &#x60;Boolean&#x60; value which indicates whether only active or suspended batches should be included. When the value is set to &#x60;true&#x60;, only suspended batches will be returned and when the value is set to &#x60;false&#x60;, only active batches will be returned.
func (r ApiGetBatchStatisticsRequest) Suspended(suspended bool) ApiGetBatchStatisticsRequest {
	r.suspended = &suspended
	return r
}

// Only include batches that were started by this user id.
func (r ApiGetBatchStatisticsRequest) CreatedBy(createdBy string) ApiGetBatchStatisticsRequest {
	r.createdBy = &createdBy
	return r
}

// Only include batches that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetBatchStatisticsRequest) StartedBefore(startedBefore time.Time) ApiGetBatchStatisticsRequest {
	r.startedBefore = &startedBefore
	return r
}

// Only include batches that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetBatchStatisticsRequest) StartedAfter(startedAfter time.Time) ApiGetBatchStatisticsRequest {
	r.startedAfter = &startedAfter
	return r
}

// Only include batches having jobs with failures. Value can only be &#x60;true&#x60;.
func (r ApiGetBatchStatisticsRequest) WithFailures(withFailures bool) ApiGetBatchStatisticsRequest {
	r.withFailures = &withFailures
	return r
}

// Only include batches having jobs without failures. Value can only be &#x60;true&#x60;.
func (r ApiGetBatchStatisticsRequest) WithoutFailures(withoutFailures bool) ApiGetBatchStatisticsRequest {
	r.withoutFailures = &withoutFailures
	return r
}

func (r ApiGetBatchStatisticsRequest) Execute() ([]BatchStatisticsDto, *http.Response, error) {
	return r.ApiService.GetBatchStatisticsExecute(r)
}

/*
GetBatchStatistics Get Statistics

Queries for batch statistics that fulfill given parameters.
Parameters may be the properties of batches, such as the id or type.
The size of the result set can be retrieved by using the 
[Get Batch Statistics Count](https://docs.camunda.org/manual/7.21/reference/rest/batch/get-statistics-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBatchStatisticsRequest
*/
func (a *BatchAPIService) GetBatchStatistics(ctx context.Context) ApiGetBatchStatisticsRequest {
	return ApiGetBatchStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BatchStatisticsDto
func (a *BatchAPIService) GetBatchStatisticsExecute(r ApiGetBatchStatisticsRequest) ([]BatchStatisticsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BatchStatisticsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.GetBatchStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/batch/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	if r.batchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchId", r.batchId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	if r.withFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withFailures", r.withFailures, "")
	}
	if r.withoutFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutFailures", r.withoutFailures, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchStatisticsCountRequest struct {
	ctx context.Context
	ApiService BatchAPI
	batchId *string
	type_ *string
	tenantIdIn *string
	withoutTenantId *bool
	suspended *bool
	createdBy *string
	startedBefore *time.Time
	startedAfter *time.Time
	withFailures *bool
	withoutFailures *bool
}

// Filter by batch id.
func (r ApiGetBatchStatisticsCountRequest) BatchId(batchId string) ApiGetBatchStatisticsCountRequest {
	r.batchId = &batchId
	return r
}

// Filter by batch type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/batch/#creating-a-batch) for more information about batch types.
func (r ApiGetBatchStatisticsCountRequest) Type_(type_ string) ApiGetBatchStatisticsCountRequest {
	r.type_ = &type_
	return r
}

// Filter by a comma-separated list of &#x60;Strings&#x60;. A batch matches if it has one of the given tenant ids.
func (r ApiGetBatchStatisticsCountRequest) TenantIdIn(tenantIdIn string) ApiGetBatchStatisticsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include batches which belong to no tenant. Value can effectively only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetBatchStatisticsCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetBatchStatisticsCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// A &#x60;Boolean&#x60; value which indicates whether only active or suspended batches should be included. When the value is set to &#x60;true&#x60;, only suspended batches will be returned and when the value is set to &#x60;false&#x60;, only active batches will be returned.
func (r ApiGetBatchStatisticsCountRequest) Suspended(suspended bool) ApiGetBatchStatisticsCountRequest {
	r.suspended = &suspended
	return r
}

// Only include batches that were started by this user id.
func (r ApiGetBatchStatisticsCountRequest) CreatedBy(createdBy string) ApiGetBatchStatisticsCountRequest {
	r.createdBy = &createdBy
	return r
}

// Only include batches that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetBatchStatisticsCountRequest) StartedBefore(startedBefore time.Time) ApiGetBatchStatisticsCountRequest {
	r.startedBefore = &startedBefore
	return r
}

// Only include batches that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetBatchStatisticsCountRequest) StartedAfter(startedAfter time.Time) ApiGetBatchStatisticsCountRequest {
	r.startedAfter = &startedAfter
	return r
}

// Only include batches having jobs with failures. Value can only be &#x60;true&#x60;.
func (r ApiGetBatchStatisticsCountRequest) WithFailures(withFailures bool) ApiGetBatchStatisticsCountRequest {
	r.withFailures = &withFailures
	return r
}

// Only include batches having jobs without failures. Value can only be &#x60;true&#x60;.
func (r ApiGetBatchStatisticsCountRequest) WithoutFailures(withoutFailures bool) ApiGetBatchStatisticsCountRequest {
	r.withoutFailures = &withoutFailures
	return r
}

func (r ApiGetBatchStatisticsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetBatchStatisticsCountExecute(r)
}

/*
GetBatchStatisticsCount Get Statistics Count

Requests the number of batch statistics that fulfill the query criteria.
Takes the same filtering parameters as the
[Get Batch Statistics](https://docs.camunda.org/manual/7.21/reference/rest/batch/get-statistics-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBatchStatisticsCountRequest
*/
func (a *BatchAPIService) GetBatchStatisticsCount(ctx context.Context) ApiGetBatchStatisticsCountRequest {
	return ApiGetBatchStatisticsCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *BatchAPIService) GetBatchStatisticsCountExecute(r ApiGetBatchStatisticsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.GetBatchStatisticsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/batch/statistics/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.batchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchId", r.batchId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	if r.withFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withFailures", r.withFailures, "")
	}
	if r.withoutFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutFailures", r.withoutFailures, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchesRequest struct {
	ctx context.Context
	ApiService BatchAPI
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
	batchId *string
	type_ *string
	tenantIdIn *string
	withoutTenantId *bool
	suspended *bool
	createdBy *string
	startedBefore *time.Time
	startedAfter *time.Time
	withFailures *bool
	withoutFailures *bool
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetBatchesRequest) SortBy(sortBy string) ApiGetBatchesRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetBatchesRequest) SortOrder(sortOrder string) ApiGetBatchesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetBatchesRequest) FirstResult(firstResult int32) ApiGetBatchesRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetBatchesRequest) MaxResults(maxResults int32) ApiGetBatchesRequest {
	r.maxResults = &maxResults
	return r
}

// Filter by batch id.
func (r ApiGetBatchesRequest) BatchId(batchId string) ApiGetBatchesRequest {
	r.batchId = &batchId
	return r
}

// Filter by batch type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/batch/#creating-a-batch) for more information about batch types.
func (r ApiGetBatchesRequest) Type_(type_ string) ApiGetBatchesRequest {
	r.type_ = &type_
	return r
}

// Filter by a comma-separated list of &#x60;Strings&#x60;. A batch matches if it has one of the given tenant ids.
func (r ApiGetBatchesRequest) TenantIdIn(tenantIdIn string) ApiGetBatchesRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include batches which belong to no tenant. Value can effectively only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetBatchesRequest) WithoutTenantId(withoutTenantId bool) ApiGetBatchesRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// A &#x60;Boolean&#x60; value which indicates whether only active or suspended batches should be included. When the value is set to &#x60;true&#x60;, only suspended batches will be returned and when the value is set to &#x60;false&#x60;, only active batches will be returned.
func (r ApiGetBatchesRequest) Suspended(suspended bool) ApiGetBatchesRequest {
	r.suspended = &suspended
	return r
}

// Only include batches that were started by this user id.
func (r ApiGetBatchesRequest) CreatedBy(createdBy string) ApiGetBatchesRequest {
	r.createdBy = &createdBy
	return r
}

// Only include batches that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetBatchesRequest) StartedBefore(startedBefore time.Time) ApiGetBatchesRequest {
	r.startedBefore = &startedBefore
	return r
}

// Only include batches that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetBatchesRequest) StartedAfter(startedAfter time.Time) ApiGetBatchesRequest {
	r.startedAfter = &startedAfter
	return r
}

// Only include batches having jobs with failures. Value can only be &#x60;true&#x60;.
func (r ApiGetBatchesRequest) WithFailures(withFailures bool) ApiGetBatchesRequest {
	r.withFailures = &withFailures
	return r
}

// Only include batches having jobs without failures. Value can only be &#x60;true&#x60;.
func (r ApiGetBatchesRequest) WithoutFailures(withoutFailures bool) ApiGetBatchesRequest {
	r.withoutFailures = &withoutFailures
	return r
}

func (r ApiGetBatchesRequest) Execute() ([]BatchDto, *http.Response, error) {
	return r.ApiService.GetBatchesExecute(r)
}

/*
GetBatches Get List

Queries for batches that fulfill given parameters. Parameters may be the properties of batches, such as the id or type.
The size of the result set can be retrieved by using the
[Get Batch Count](https://docs.camunda.org/manual/7.21/reference/rest/batch/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBatchesRequest
*/
func (a *BatchAPIService) GetBatches(ctx context.Context) ApiGetBatchesRequest {
	return ApiGetBatchesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BatchDto
func (a *BatchAPIService) GetBatchesExecute(r ApiGetBatchesRequest) ([]BatchDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BatchDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.GetBatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	if r.batchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchId", r.batchId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	if r.withFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withFailures", r.withFailures, "")
	}
	if r.withoutFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutFailures", r.withoutFailures, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchesCountRequest struct {
	ctx context.Context
	ApiService BatchAPI
	batchId *string
	type_ *string
	tenantIdIn *string
	withoutTenantId *bool
	suspended *bool
	createdBy *string
	startedBefore *time.Time
	startedAfter *time.Time
	withFailures *bool
	withoutFailures *bool
}

// Filter by batch id.
func (r ApiGetBatchesCountRequest) BatchId(batchId string) ApiGetBatchesCountRequest {
	r.batchId = &batchId
	return r
}

// Filter by batch type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/batch/#creating-a-batch) for more information about batch types.
func (r ApiGetBatchesCountRequest) Type_(type_ string) ApiGetBatchesCountRequest {
	r.type_ = &type_
	return r
}

// Filter by a comma-separated list of &#x60;Strings&#x60;. A batch matches if it has one of the given tenant ids.
func (r ApiGetBatchesCountRequest) TenantIdIn(tenantIdIn string) ApiGetBatchesCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include batches which belong to no tenant. Value can effectively only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetBatchesCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetBatchesCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// A &#x60;Boolean&#x60; value which indicates whether only active or suspended batches should be included. When the value is set to &#x60;true&#x60;, only suspended batches will be returned and when the value is set to &#x60;false&#x60;, only active batches will be returned.
func (r ApiGetBatchesCountRequest) Suspended(suspended bool) ApiGetBatchesCountRequest {
	r.suspended = &suspended
	return r
}

// Only include batches that were started by this user id.
func (r ApiGetBatchesCountRequest) CreatedBy(createdBy string) ApiGetBatchesCountRequest {
	r.createdBy = &createdBy
	return r
}

// Only include batches that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetBatchesCountRequest) StartedBefore(startedBefore time.Time) ApiGetBatchesCountRequest {
	r.startedBefore = &startedBefore
	return r
}

// Only include batches that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetBatchesCountRequest) StartedAfter(startedAfter time.Time) ApiGetBatchesCountRequest {
	r.startedAfter = &startedAfter
	return r
}

// Only include batches having jobs with failures. Value can only be &#x60;true&#x60;.
func (r ApiGetBatchesCountRequest) WithFailures(withFailures bool) ApiGetBatchesCountRequest {
	r.withFailures = &withFailures
	return r
}

// Only include batches having jobs without failures. Value can only be &#x60;true&#x60;.
func (r ApiGetBatchesCountRequest) WithoutFailures(withoutFailures bool) ApiGetBatchesCountRequest {
	r.withoutFailures = &withoutFailures
	return r
}

func (r ApiGetBatchesCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetBatchesCountExecute(r)
}

/*
GetBatchesCount Get List Count

Requests the number of batches that fulfill the query criteria.
Takes the same filtering parameters as the [Get Batches](https://docs.camunda.org/manual/7.21/reference/rest/batch/get-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBatchesCountRequest
*/
func (a *BatchAPIService) GetBatchesCount(ctx context.Context) ApiGetBatchesCountRequest {
	return ApiGetBatchesCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *BatchAPIService) GetBatchesCountExecute(r ApiGetBatchesCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.GetBatchesCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/batch/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.batchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchId", r.batchId, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBy", r.createdBy, "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	if r.withFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withFailures", r.withFailures, "")
	}
	if r.withoutFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutFailures", r.withoutFailures, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBatchSuspensionStateRequest struct {
	ctx context.Context
	ApiService BatchAPI
	id string
	suspensionStateDto *SuspensionStateDto
}

func (r ApiUpdateBatchSuspensionStateRequest) SuspensionStateDto(suspensionStateDto SuspensionStateDto) ApiUpdateBatchSuspensionStateRequest {
	r.suspensionStateDto = &suspensionStateDto
	return r
}

func (r ApiUpdateBatchSuspensionStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateBatchSuspensionStateExecute(r)
}

/*
UpdateBatchSuspensionState Activate/Suspend

Activates or suspends a batch by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the batch to activate or suspend.
 @return ApiUpdateBatchSuspensionStateRequest
*/
func (a *BatchAPIService) UpdateBatchSuspensionState(ctx context.Context, id string) ApiUpdateBatchSuspensionStateRequest {
	return ApiUpdateBatchSuspensionStateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *BatchAPIService) UpdateBatchSuspensionStateExecute(r ApiUpdateBatchSuspensionStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.UpdateBatchSuspensionState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/batch/{id}/suspended"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.suspensionStateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
