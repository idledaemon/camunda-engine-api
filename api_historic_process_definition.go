/*
Camunda Platform REST API

OpenApi Spec for Camunda Platform REST API.

API version: 7.21.2-ee
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package camundarestgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


type HistoricProcessDefinitionAPI interface {

	/*
	GetCleanableHistoricProcessInstanceReport Get Cleanable Process Instance Report

	Retrieves a report about a process definition and finished process instances
relevant to history cleanup (see
[History cleanup](https://docs.camunda.org/manual/7.21/user-guide/process-engine/history/#history-cleanup)) 
so that you can tune the history time to live.
These reports include the count of the finished historic process
instances, cleanable process instances and basic process definition
data - id, key, name and version.
The size of the result set can be retrieved by using the
[Get Cleanable Process Instance Report Count](https://docs.camunda.org/manual/7.21/reference/rest/history/process-definition/get-cleanable-process-instance-report-count/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCleanableHistoricProcessInstanceReportRequest
	*/
	GetCleanableHistoricProcessInstanceReport(ctx context.Context) ApiGetCleanableHistoricProcessInstanceReportRequest

	// GetCleanableHistoricProcessInstanceReportExecute executes the request
	//  @return []CleanableHistoricProcessInstanceReportResultDto
	GetCleanableHistoricProcessInstanceReportExecute(r ApiGetCleanableHistoricProcessInstanceReportRequest) ([]CleanableHistoricProcessInstanceReportResultDto, *http.Response, error)

	/*
	GetCleanableHistoricProcessInstanceReportCount Get Cleanable Process Instance Report Count

	Queries for the number of report results about a process definition and finished
process instances relevant to history cleanup (see
[History cleanup](https://docs.camunda.org/manual/7.21/user-guide/process-engine/history/#history-cleanup)).
Takes the same parameters as the
[Get Cleanable Process Instance Report](https://docs.camunda.org/manual/7.21/reference/rest/history/process-definition/get-cleanable-process-instance-report/)
method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCleanableHistoricProcessInstanceReportCountRequest
	*/
	GetCleanableHistoricProcessInstanceReportCount(ctx context.Context) ApiGetCleanableHistoricProcessInstanceReportCountRequest

	// GetCleanableHistoricProcessInstanceReportCountExecute executes the request
	//  @return CountResultDto
	GetCleanableHistoricProcessInstanceReportCountExecute(r ApiGetCleanableHistoricProcessInstanceReportCountRequest) (*CountResultDto, *http.Response, error)

	/*
	GetHistoricActivityStatistics Get Historic Activity Statistics

	Retrieves historic statistics of a given process definition, grouped by activities.
These statistics include the number of running activity instances and,
optionally, the number of canceled activity instances, finished
activity instances and activity instances which completed a scope
(i.e., in BPMN 2.0 manner: a scope is completed by an activity
instance when the activity instance consumed a token but did not emit
a new token).
**Note:** This only includes historic data.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the process definition.
	@return ApiGetHistoricActivityStatisticsRequest
	*/
	GetHistoricActivityStatistics(ctx context.Context, id string) ApiGetHistoricActivityStatisticsRequest

	// GetHistoricActivityStatisticsExecute executes the request
	//  @return []HistoricActivityStatisticsDto
	GetHistoricActivityStatisticsExecute(r ApiGetHistoricActivityStatisticsRequest) ([]HistoricActivityStatisticsDto, *http.Response, error)
}

// HistoricProcessDefinitionAPIService HistoricProcessDefinitionAPI service
type HistoricProcessDefinitionAPIService service

type ApiGetCleanableHistoricProcessInstanceReportRequest struct {
	ctx context.Context
	ApiService HistoricProcessDefinitionAPI
	processDefinitionIdIn *string
	processDefinitionKeyIn *string
	tenantIdIn *string
	withoutTenantId *bool
	compact *bool
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Filter by process definition ids. Must be a comma-separated list of process definition ids.
func (r ApiGetCleanableHistoricProcessInstanceReportRequest) ProcessDefinitionIdIn(processDefinitionIdIn string) ApiGetCleanableHistoricProcessInstanceReportRequest {
	r.processDefinitionIdIn = &processDefinitionIdIn
	return r
}

// Filter by process definition keys. Must be a comma-separated list of process definition keys.
func (r ApiGetCleanableHistoricProcessInstanceReportRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetCleanableHistoricProcessInstanceReportRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Filter by a comma-separated list of tenant ids. A process definition must have one of the given  tenant ids.
func (r ApiGetCleanableHistoricProcessInstanceReportRequest) TenantIdIn(tenantIdIn string) ApiGetCleanableHistoricProcessInstanceReportRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include process definitions which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetCleanableHistoricProcessInstanceReportRequest) WithoutTenantId(withoutTenantId bool) ApiGetCleanableHistoricProcessInstanceReportRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Only include process instances which have more than zero finished instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetCleanableHistoricProcessInstanceReportRequest) Compact(compact bool) ApiGetCleanableHistoricProcessInstanceReportRequest {
	r.compact = &compact
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetCleanableHistoricProcessInstanceReportRequest) SortBy(sortBy string) ApiGetCleanableHistoricProcessInstanceReportRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetCleanableHistoricProcessInstanceReportRequest) SortOrder(sortOrder string) ApiGetCleanableHistoricProcessInstanceReportRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetCleanableHistoricProcessInstanceReportRequest) FirstResult(firstResult int32) ApiGetCleanableHistoricProcessInstanceReportRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetCleanableHistoricProcessInstanceReportRequest) MaxResults(maxResults int32) ApiGetCleanableHistoricProcessInstanceReportRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetCleanableHistoricProcessInstanceReportRequest) Execute() ([]CleanableHistoricProcessInstanceReportResultDto, *http.Response, error) {
	return r.ApiService.GetCleanableHistoricProcessInstanceReportExecute(r)
}

/*
GetCleanableHistoricProcessInstanceReport Get Cleanable Process Instance Report

Retrieves a report about a process definition and finished process instances
relevant to history cleanup (see
[History cleanup](https://docs.camunda.org/manual/7.21/user-guide/process-engine/history/#history-cleanup)) 
so that you can tune the history time to live.
These reports include the count of the finished historic process
instances, cleanable process instances and basic process definition
data - id, key, name and version.
The size of the result set can be retrieved by using the
[Get Cleanable Process Instance Report Count](https://docs.camunda.org/manual/7.21/reference/rest/history/process-definition/get-cleanable-process-instance-report-count/)
method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCleanableHistoricProcessInstanceReportRequest
*/
func (a *HistoricProcessDefinitionAPIService) GetCleanableHistoricProcessInstanceReport(ctx context.Context) ApiGetCleanableHistoricProcessInstanceReportRequest {
	return ApiGetCleanableHistoricProcessInstanceReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CleanableHistoricProcessInstanceReportResultDto
func (a *HistoricProcessDefinitionAPIService) GetCleanableHistoricProcessInstanceReportExecute(r ApiGetCleanableHistoricProcessInstanceReportRequest) ([]CleanableHistoricProcessInstanceReportResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CleanableHistoricProcessInstanceReportResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricProcessDefinitionAPIService.GetCleanableHistoricProcessInstanceReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/process-definition/cleanable-process-instance-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.processDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionIdIn", r.processDefinitionIdIn, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.compact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compact", r.compact, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCleanableHistoricProcessInstanceReportCountRequest struct {
	ctx context.Context
	ApiService HistoricProcessDefinitionAPI
	processDefinitionIdIn *string
	processDefinitionKeyIn *string
	tenantIdIn *string
	withoutTenantId *bool
	compact *bool
}

// Filter by process definition ids. Must be a comma-separated list of process definition ids.
func (r ApiGetCleanableHistoricProcessInstanceReportCountRequest) ProcessDefinitionIdIn(processDefinitionIdIn string) ApiGetCleanableHistoricProcessInstanceReportCountRequest {
	r.processDefinitionIdIn = &processDefinitionIdIn
	return r
}

// Filter by process definition keys. Must be a comma-separated list of process definition keys.
func (r ApiGetCleanableHistoricProcessInstanceReportCountRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetCleanableHistoricProcessInstanceReportCountRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Filter by a comma-separated list of tenant ids. A process definition must have one of the given  tenant ids.
func (r ApiGetCleanableHistoricProcessInstanceReportCountRequest) TenantIdIn(tenantIdIn string) ApiGetCleanableHistoricProcessInstanceReportCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include process definitions which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetCleanableHistoricProcessInstanceReportCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetCleanableHistoricProcessInstanceReportCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Only include process instances which have more than zero finished instances. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetCleanableHistoricProcessInstanceReportCountRequest) Compact(compact bool) ApiGetCleanableHistoricProcessInstanceReportCountRequest {
	r.compact = &compact
	return r
}

func (r ApiGetCleanableHistoricProcessInstanceReportCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetCleanableHistoricProcessInstanceReportCountExecute(r)
}

/*
GetCleanableHistoricProcessInstanceReportCount Get Cleanable Process Instance Report Count

Queries for the number of report results about a process definition and finished
process instances relevant to history cleanup (see
[History cleanup](https://docs.camunda.org/manual/7.21/user-guide/process-engine/history/#history-cleanup)).
Takes the same parameters as the
[Get Cleanable Process Instance Report](https://docs.camunda.org/manual/7.21/reference/rest/history/process-definition/get-cleanable-process-instance-report/)
method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCleanableHistoricProcessInstanceReportCountRequest
*/
func (a *HistoricProcessDefinitionAPIService) GetCleanableHistoricProcessInstanceReportCount(ctx context.Context) ApiGetCleanableHistoricProcessInstanceReportCountRequest {
	return ApiGetCleanableHistoricProcessInstanceReportCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *HistoricProcessDefinitionAPIService) GetCleanableHistoricProcessInstanceReportCountExecute(r ApiGetCleanableHistoricProcessInstanceReportCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricProcessDefinitionAPIService.GetCleanableHistoricProcessInstanceReportCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/process-definition/cleanable-process-instance-report/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.processDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionIdIn", r.processDefinitionIdIn, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	}
	if r.compact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compact", r.compact, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricActivityStatisticsRequest struct {
	ctx context.Context
	ApiService HistoricProcessDefinitionAPI
	id string
	canceled *bool
	finished *bool
	completeScope *bool
	incidents *bool
	startedBefore *time.Time
	startedAfter *time.Time
	finishedBefore *time.Time
	finishedAfter *time.Time
	processInstanceIdIn *string
	sortBy *string
	sortOrder *string
}

// Whether to include the number of canceled activity instances in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. Default: &#x60;false&#x60;.
func (r ApiGetHistoricActivityStatisticsRequest) Canceled(canceled bool) ApiGetHistoricActivityStatisticsRequest {
	r.canceled = &canceled
	return r
}

// Whether to include the number of finished activity instances in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. Default: &#x60;false&#x60;.
func (r ApiGetHistoricActivityStatisticsRequest) Finished(finished bool) ApiGetHistoricActivityStatisticsRequest {
	r.finished = &finished
	return r
}

// Whether to include the number of activity instances which completed a scope in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. Default: &#x60;false&#x60;.
func (r ApiGetHistoricActivityStatisticsRequest) CompleteScope(completeScope bool) ApiGetHistoricActivityStatisticsRequest {
	r.completeScope = &completeScope
	return r
}

// Whether to include the number of incidents. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. Default: &#x60;false&#x60;.
func (r ApiGetHistoricActivityStatisticsRequest) Incidents(incidents bool) ApiGetHistoricActivityStatisticsRequest {
	r.incidents = &incidents
	return r
}

// Restrict to process instances that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/),  the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;,  e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityStatisticsRequest) StartedBefore(startedBefore time.Time) ApiGetHistoricActivityStatisticsRequest {
	r.startedBefore = &startedBefore
	return r
}

// Restrict to process instances that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/),  the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;,  e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityStatisticsRequest) StartedAfter(startedAfter time.Time) ApiGetHistoricActivityStatisticsRequest {
	r.startedAfter = &startedAfter
	return r
}

// Restrict to process instances that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/),  the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;,  e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityStatisticsRequest) FinishedBefore(finishedBefore time.Time) ApiGetHistoricActivityStatisticsRequest {
	r.finishedBefore = &finishedBefore
	return r
}

// Restrict to process instances that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/),  the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;,  e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetHistoricActivityStatisticsRequest) FinishedAfter(finishedAfter time.Time) ApiGetHistoricActivityStatisticsRequest {
	r.finishedAfter = &finishedAfter
	return r
}

// Restrict to process instances with the given IDs. The IDs must be provided as a comma- separated list.
func (r ApiGetHistoricActivityStatisticsRequest) ProcessInstanceIdIn(processInstanceIdIn string) ApiGetHistoricActivityStatisticsRequest {
	r.processInstanceIdIn = &processInstanceIdIn
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetHistoricActivityStatisticsRequest) SortBy(sortBy string) ApiGetHistoricActivityStatisticsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetHistoricActivityStatisticsRequest) SortOrder(sortOrder string) ApiGetHistoricActivityStatisticsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetHistoricActivityStatisticsRequest) Execute() ([]HistoricActivityStatisticsDto, *http.Response, error) {
	return r.ApiService.GetHistoricActivityStatisticsExecute(r)
}

/*
GetHistoricActivityStatistics Get Historic Activity Statistics

Retrieves historic statistics of a given process definition, grouped by activities.
These statistics include the number of running activity instances and,
optionally, the number of canceled activity instances, finished
activity instances and activity instances which completed a scope
(i.e., in BPMN 2.0 manner: a scope is completed by an activity
instance when the activity instance consumed a token but did not emit
a new token).
**Note:** This only includes historic data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the process definition.
 @return ApiGetHistoricActivityStatisticsRequest
*/
func (a *HistoricProcessDefinitionAPIService) GetHistoricActivityStatistics(ctx context.Context, id string) ApiGetHistoricActivityStatisticsRequest {
	return ApiGetHistoricActivityStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []HistoricActivityStatisticsDto
func (a *HistoricProcessDefinitionAPIService) GetHistoricActivityStatisticsExecute(r ApiGetHistoricActivityStatisticsRequest) ([]HistoricActivityStatisticsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HistoricActivityStatisticsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HistoricProcessDefinitionAPIService.GetHistoricActivityStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/process-definition/{id}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.canceled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "canceled", r.canceled, "")
	}
	if r.finished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finished", r.finished, "")
	}
	if r.completeScope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completeScope", r.completeScope, "")
	}
	if r.incidents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidents", r.incidents, "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	if r.finishedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finishedBefore", r.finishedBefore, "")
	}
	if r.finishedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finishedAfter", r.finishedAfter, "")
	}
	if r.processInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIdIn", r.processInstanceIdIn, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
