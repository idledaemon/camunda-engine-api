/*
Camunda Platform REST API

OpenApi Spec for Camunda Platform REST API.

API version: 7.21.2-ee
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package camundarestgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


type IncidentAPI interface {

	/*
	ClearIncidentAnnotation Clear Incident Annotation

	Clears the annotation of an incident with given id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the incident to clear the annotation at.
	@return ApiClearIncidentAnnotationRequest
	*/
	ClearIncidentAnnotation(ctx context.Context, id string) ApiClearIncidentAnnotationRequest

	// ClearIncidentAnnotationExecute executes the request
	ClearIncidentAnnotationExecute(r ApiClearIncidentAnnotationRequest) (*http.Response, error)

	/*
	GetIncident Get Incident

	Retrieves an incident by ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the incident to be retrieved.
	@return ApiGetIncidentRequest
	*/
	GetIncident(ctx context.Context, id string) ApiGetIncidentRequest

	// GetIncidentExecute executes the request
	//  @return IncidentDto
	GetIncidentExecute(r ApiGetIncidentRequest) (*IncidentDto, *http.Response, error)

	/*
	GetIncidents Get List

	Queries for incidents that fulfill given parameters. The size of the result set can be retrieved by using
the [Get Incident Count](https://docs.camunda.org/manual/7.21/reference/rest/incident/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIncidentsRequest
	*/
	GetIncidents(ctx context.Context) ApiGetIncidentsRequest

	// GetIncidentsExecute executes the request
	//  @return []IncidentDto
	GetIncidentsExecute(r ApiGetIncidentsRequest) ([]IncidentDto, *http.Response, error)

	/*
	GetIncidentsCount Get List Count

	Queries for the number of incidents that fulfill given parameters. Takes the same parameters as the
[Get Incidents](https://docs.camunda.org/manual/7.21/reference/rest/incident/get-query/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIncidentsCountRequest
	*/
	GetIncidentsCount(ctx context.Context) ApiGetIncidentsCountRequest

	// GetIncidentsCountExecute executes the request
	//  @return CountResultDto
	GetIncidentsCountExecute(r ApiGetIncidentsCountRequest) (*CountResultDto, *http.Response, error)

	/*
	ResolveIncident Resolve Incident

	Resolves an incident with given id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the incident to be resolved.
	@return ApiResolveIncidentRequest
	*/
	ResolveIncident(ctx context.Context, id string) ApiResolveIncidentRequest

	// ResolveIncidentExecute executes the request
	ResolveIncidentExecute(r ApiResolveIncidentRequest) (*http.Response, error)

	/*
	SetIncidentAnnotation Set Incident Annotation

	Sets the annotation of an incident with given id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the incident to clear the annotation at.
	@return ApiSetIncidentAnnotationRequest
	*/
	SetIncidentAnnotation(ctx context.Context, id string) ApiSetIncidentAnnotationRequest

	// SetIncidentAnnotationExecute executes the request
	SetIncidentAnnotationExecute(r ApiSetIncidentAnnotationRequest) (*http.Response, error)
}

// IncidentAPIService IncidentAPI service
type IncidentAPIService service

type ApiClearIncidentAnnotationRequest struct {
	ctx context.Context
	ApiService IncidentAPI
	id string
}

func (r ApiClearIncidentAnnotationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearIncidentAnnotationExecute(r)
}

/*
ClearIncidentAnnotation Clear Incident Annotation

Clears the annotation of an incident with given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the incident to clear the annotation at.
 @return ApiClearIncidentAnnotationRequest
*/
func (a *IncidentAPIService) ClearIncidentAnnotation(ctx context.Context, id string) ApiClearIncidentAnnotationRequest {
	return ApiClearIncidentAnnotationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IncidentAPIService) ClearIncidentAnnotationExecute(r ApiClearIncidentAnnotationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.ClearIncidentAnnotation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/{id}/annotation"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIncidentRequest struct {
	ctx context.Context
	ApiService IncidentAPI
	id string
}

func (r ApiGetIncidentRequest) Execute() (*IncidentDto, *http.Response, error) {
	return r.ApiService.GetIncidentExecute(r)
}

/*
GetIncident Get Incident

Retrieves an incident by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the incident to be retrieved.
 @return ApiGetIncidentRequest
*/
func (a *IncidentAPIService) GetIncident(ctx context.Context, id string) ApiGetIncidentRequest {
	return ApiGetIncidentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IncidentDto
func (a *IncidentAPIService) GetIncidentExecute(r ApiGetIncidentRequest) (*IncidentDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IncidentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.GetIncident")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIncidentsRequest struct {
	ctx context.Context
	ApiService IncidentAPI
	incidentId *string
	incidentType *string
	incidentMessage *string
	incidentMessageLike *string
	processDefinitionId *string
	processDefinitionKeyIn *string
	processInstanceId *string
	executionId *string
	incidentTimestampBefore *time.Time
	incidentTimestampAfter *time.Time
	activityId *string
	failedActivityId *string
	causeIncidentId *string
	rootCauseIncidentId *string
	configuration *string
	tenantIdIn *string
	jobDefinitionIdIn *string
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Restricts to incidents that have the given id.
func (r ApiGetIncidentsRequest) IncidentId(incidentId string) ApiGetIncidentsRequest {
	r.incidentId = &incidentId
	return r
}

// Restricts to incidents that belong to the given incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetIncidentsRequest) IncidentType(incidentType string) ApiGetIncidentsRequest {
	r.incidentType = &incidentType
	return r
}

// Restricts to incidents that have the given incident message.
func (r ApiGetIncidentsRequest) IncidentMessage(incidentMessage string) ApiGetIncidentsRequest {
	r.incidentMessage = &incidentMessage
	return r
}

// Restricts to incidents that incidents message is a substring of the given value. The string can include the wildcard character &#39;%&#39; to express like-strategy: starts with (&#x60;string%&#x60;), ends with (&#x60;%string&#x60;) or contains (&#x60;%string%&#x60;).
func (r ApiGetIncidentsRequest) IncidentMessageLike(incidentMessageLike string) ApiGetIncidentsRequest {
	r.incidentMessageLike = &incidentMessageLike
	return r
}

// Restricts to incidents that belong to a process definition with the given id.
func (r ApiGetIncidentsRequest) ProcessDefinitionId(processDefinitionId string) ApiGetIncidentsRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Restricts to incidents that belong to a process definition with the given keys. Must be a comma-separated list.
func (r ApiGetIncidentsRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetIncidentsRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restricts to incidents that belong to a process instance with the given id.
func (r ApiGetIncidentsRequest) ProcessInstanceId(processInstanceId string) ApiGetIncidentsRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Restricts to incidents that belong to an execution with the given id.
func (r ApiGetIncidentsRequest) ExecutionId(executionId string) ApiGetIncidentsRequest {
	r.executionId = &executionId
	return r
}

// Restricts to incidents that have an incidentTimestamp date before the given date.  By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetIncidentsRequest) IncidentTimestampBefore(incidentTimestampBefore time.Time) ApiGetIncidentsRequest {
	r.incidentTimestampBefore = &incidentTimestampBefore
	return r
}

// Restricts to incidents that have an incidentTimestamp date after the given date.  By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetIncidentsRequest) IncidentTimestampAfter(incidentTimestampAfter time.Time) ApiGetIncidentsRequest {
	r.incidentTimestampAfter = &incidentTimestampAfter
	return r
}

// Restricts to incidents that belong to an activity with the given id.
func (r ApiGetIncidentsRequest) ActivityId(activityId string) ApiGetIncidentsRequest {
	r.activityId = &activityId
	return r
}

// Restricts to incidents that were created due to the failure of an activity with the given id.
func (r ApiGetIncidentsRequest) FailedActivityId(failedActivityId string) ApiGetIncidentsRequest {
	r.failedActivityId = &failedActivityId
	return r
}

// Restricts to incidents that have the given incident id as cause incident.
func (r ApiGetIncidentsRequest) CauseIncidentId(causeIncidentId string) ApiGetIncidentsRequest {
	r.causeIncidentId = &causeIncidentId
	return r
}

// Restricts to incidents that have the given incident id as root cause incident.
func (r ApiGetIncidentsRequest) RootCauseIncidentId(rootCauseIncidentId string) ApiGetIncidentsRequest {
	r.rootCauseIncidentId = &rootCauseIncidentId
	return r
}

// Restricts to incidents that have the given parameter set as configuration.
func (r ApiGetIncidentsRequest) Configuration(configuration string) ApiGetIncidentsRequest {
	r.configuration = &configuration
	return r
}

// Restricts to incidents that have one of the given comma-separated tenant ids.
func (r ApiGetIncidentsRequest) TenantIdIn(tenantIdIn string) ApiGetIncidentsRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Restricts to incidents that have one of the given comma-separated job definition ids.
func (r ApiGetIncidentsRequest) JobDefinitionIdIn(jobDefinitionIdIn string) ApiGetIncidentsRequest {
	r.jobDefinitionIdIn = &jobDefinitionIdIn
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetIncidentsRequest) SortBy(sortBy string) ApiGetIncidentsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetIncidentsRequest) SortOrder(sortOrder string) ApiGetIncidentsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetIncidentsRequest) FirstResult(firstResult int32) ApiGetIncidentsRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetIncidentsRequest) MaxResults(maxResults int32) ApiGetIncidentsRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetIncidentsRequest) Execute() ([]IncidentDto, *http.Response, error) {
	return r.ApiService.GetIncidentsExecute(r)
}

/*
GetIncidents Get List

Queries for incidents that fulfill given parameters. The size of the result set can be retrieved by using
the [Get Incident Count](https://docs.camunda.org/manual/7.21/reference/rest/incident/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIncidentsRequest
*/
func (a *IncidentAPIService) GetIncidents(ctx context.Context) ApiGetIncidentsRequest {
	return ApiGetIncidentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IncidentDto
func (a *IncidentAPIService) GetIncidentsExecute(r ApiGetIncidentsRequest) ([]IncidentDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IncidentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.GetIncidents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.incidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentId", r.incidentId, "")
	}
	if r.incidentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentType", r.incidentType, "")
	}
	if r.incidentMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessage", r.incidentMessage, "")
	}
	if r.incidentMessageLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessageLike", r.incidentMessageLike, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.incidentTimestampBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentTimestampBefore", r.incidentTimestampBefore, "")
	}
	if r.incidentTimestampAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentTimestampAfter", r.incidentTimestampAfter, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.failedActivityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedActivityId", r.failedActivityId, "")
	}
	if r.causeIncidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "causeIncidentId", r.causeIncidentId, "")
	}
	if r.rootCauseIncidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootCauseIncidentId", r.rootCauseIncidentId, "")
	}
	if r.configuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configuration", r.configuration, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.jobDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobDefinitionIdIn", r.jobDefinitionIdIn, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIncidentsCountRequest struct {
	ctx context.Context
	ApiService IncidentAPI
	incidentId *string
	incidentType *string
	incidentMessage *string
	incidentMessageLike *string
	processDefinitionId *string
	processDefinitionKeyIn *string
	processInstanceId *string
	executionId *string
	incidentTimestampBefore *time.Time
	incidentTimestampAfter *time.Time
	activityId *string
	failedActivityId *string
	causeIncidentId *string
	rootCauseIncidentId *string
	configuration *string
	tenantIdIn *string
	jobDefinitionIdIn *string
}

// Restricts to incidents that have the given id.
func (r ApiGetIncidentsCountRequest) IncidentId(incidentId string) ApiGetIncidentsCountRequest {
	r.incidentId = &incidentId
	return r
}

// Restricts to incidents that belong to the given incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
func (r ApiGetIncidentsCountRequest) IncidentType(incidentType string) ApiGetIncidentsCountRequest {
	r.incidentType = &incidentType
	return r
}

// Restricts to incidents that have the given incident message.
func (r ApiGetIncidentsCountRequest) IncidentMessage(incidentMessage string) ApiGetIncidentsCountRequest {
	r.incidentMessage = &incidentMessage
	return r
}

// Restricts to incidents that incidents message is a substring of the given value. The string can include the wildcard character &#39;%&#39; to express like-strategy: starts with (&#x60;string%&#x60;), ends with (&#x60;%string&#x60;) or contains (&#x60;%string%&#x60;).
func (r ApiGetIncidentsCountRequest) IncidentMessageLike(incidentMessageLike string) ApiGetIncidentsCountRequest {
	r.incidentMessageLike = &incidentMessageLike
	return r
}

// Restricts to incidents that belong to a process definition with the given id.
func (r ApiGetIncidentsCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetIncidentsCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Restricts to incidents that belong to a process definition with the given keys. Must be a comma-separated list.
func (r ApiGetIncidentsCountRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetIncidentsCountRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restricts to incidents that belong to a process instance with the given id.
func (r ApiGetIncidentsCountRequest) ProcessInstanceId(processInstanceId string) ApiGetIncidentsCountRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Restricts to incidents that belong to an execution with the given id.
func (r ApiGetIncidentsCountRequest) ExecutionId(executionId string) ApiGetIncidentsCountRequest {
	r.executionId = &executionId
	return r
}

// Restricts to incidents that have an incidentTimestamp date before the given date.  By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetIncidentsCountRequest) IncidentTimestampBefore(incidentTimestampBefore time.Time) ApiGetIncidentsCountRequest {
	r.incidentTimestampBefore = &incidentTimestampBefore
	return r
}

// Restricts to incidents that have an incidentTimestamp date after the given date.  By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
func (r ApiGetIncidentsCountRequest) IncidentTimestampAfter(incidentTimestampAfter time.Time) ApiGetIncidentsCountRequest {
	r.incidentTimestampAfter = &incidentTimestampAfter
	return r
}

// Restricts to incidents that belong to an activity with the given id.
func (r ApiGetIncidentsCountRequest) ActivityId(activityId string) ApiGetIncidentsCountRequest {
	r.activityId = &activityId
	return r
}

// Restricts to incidents that were created due to the failure of an activity with the given id.
func (r ApiGetIncidentsCountRequest) FailedActivityId(failedActivityId string) ApiGetIncidentsCountRequest {
	r.failedActivityId = &failedActivityId
	return r
}

// Restricts to incidents that have the given incident id as cause incident.
func (r ApiGetIncidentsCountRequest) CauseIncidentId(causeIncidentId string) ApiGetIncidentsCountRequest {
	r.causeIncidentId = &causeIncidentId
	return r
}

// Restricts to incidents that have the given incident id as root cause incident.
func (r ApiGetIncidentsCountRequest) RootCauseIncidentId(rootCauseIncidentId string) ApiGetIncidentsCountRequest {
	r.rootCauseIncidentId = &rootCauseIncidentId
	return r
}

// Restricts to incidents that have the given parameter set as configuration.
func (r ApiGetIncidentsCountRequest) Configuration(configuration string) ApiGetIncidentsCountRequest {
	r.configuration = &configuration
	return r
}

// Restricts to incidents that have one of the given comma-separated tenant ids.
func (r ApiGetIncidentsCountRequest) TenantIdIn(tenantIdIn string) ApiGetIncidentsCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Restricts to incidents that have one of the given comma-separated job definition ids.
func (r ApiGetIncidentsCountRequest) JobDefinitionIdIn(jobDefinitionIdIn string) ApiGetIncidentsCountRequest {
	r.jobDefinitionIdIn = &jobDefinitionIdIn
	return r
}

func (r ApiGetIncidentsCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetIncidentsCountExecute(r)
}

/*
GetIncidentsCount Get List Count

Queries for the number of incidents that fulfill given parameters. Takes the same parameters as the
[Get Incidents](https://docs.camunda.org/manual/7.21/reference/rest/incident/get-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIncidentsCountRequest
*/
func (a *IncidentAPIService) GetIncidentsCount(ctx context.Context) ApiGetIncidentsCountRequest {
	return ApiGetIncidentsCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *IncidentAPIService) GetIncidentsCountExecute(r ApiGetIncidentsCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.GetIncidentsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.incidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentId", r.incidentId, "")
	}
	if r.incidentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentType", r.incidentType, "")
	}
	if r.incidentMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessage", r.incidentMessage, "")
	}
	if r.incidentMessageLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentMessageLike", r.incidentMessageLike, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.incidentTimestampBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentTimestampBefore", r.incidentTimestampBefore, "")
	}
	if r.incidentTimestampAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentTimestampAfter", r.incidentTimestampAfter, "")
	}
	if r.activityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityId", r.activityId, "")
	}
	if r.failedActivityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedActivityId", r.failedActivityId, "")
	}
	if r.causeIncidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "causeIncidentId", r.causeIncidentId, "")
	}
	if r.rootCauseIncidentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootCauseIncidentId", r.rootCauseIncidentId, "")
	}
	if r.configuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configuration", r.configuration, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.jobDefinitionIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobDefinitionIdIn", r.jobDefinitionIdIn, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResolveIncidentRequest struct {
	ctx context.Context
	ApiService IncidentAPI
	id string
}

func (r ApiResolveIncidentRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResolveIncidentExecute(r)
}

/*
ResolveIncident Resolve Incident

Resolves an incident with given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the incident to be resolved.
 @return ApiResolveIncidentRequest
*/
func (a *IncidentAPIService) ResolveIncident(ctx context.Context, id string) ApiResolveIncidentRequest {
	return ApiResolveIncidentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IncidentAPIService) ResolveIncidentExecute(r ApiResolveIncidentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.ResolveIncident")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetIncidentAnnotationRequest struct {
	ctx context.Context
	ApiService IncidentAPI
	id string
	annotationDto *AnnotationDto
}

func (r ApiSetIncidentAnnotationRequest) AnnotationDto(annotationDto AnnotationDto) ApiSetIncidentAnnotationRequest {
	r.annotationDto = &annotationDto
	return r
}

func (r ApiSetIncidentAnnotationRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetIncidentAnnotationExecute(r)
}

/*
SetIncidentAnnotation Set Incident Annotation

Sets the annotation of an incident with given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the incident to clear the annotation at.
 @return ApiSetIncidentAnnotationRequest
*/
func (a *IncidentAPIService) SetIncidentAnnotation(ctx context.Context, id string) ApiSetIncidentAnnotationRequest {
	return ApiSetIncidentAnnotationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IncidentAPIService) SetIncidentAnnotationExecute(r ApiSetIncidentAnnotationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentAPIService.SetIncidentAnnotation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incident/{id}/annotation"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.annotationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
