/*
Camunda Platform REST API

OpenApi Spec for Camunda Platform REST API.

API version: 7.21.2-ee
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package camundarestgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type UserAPI interface {

	/*
	AvailableOperations Options

	The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such
and one for individual user instances. The `OPTIONS` request allows checking for the set of
available operations that the currently authenticated user can perform on the /user resource.
If the user can perform an operation or not may depend on various things, including the user's
authorizations to interact with this resource and the internal configuration of the process
engine. `OPTIONS /user` returns available interactions on the resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAvailableOperationsRequest
	*/
	AvailableOperations(ctx context.Context) ApiAvailableOperationsRequest

	// AvailableOperationsExecute executes the request
	//  @return ResourceOptionsDto
	AvailableOperationsExecute(r ApiAvailableOperationsRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	AvailableUserOperations Options

	The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such
and one for individual user instances. The `OPTIONS` request allows checking for the set of
available operations that the currently authenticated user can perform on the /user resource.
If the user can perform an operation or not may depend on various things, including the user's
authorizations to interact with this resource and the internal configuration of the process
engine. `OPTIONS /user/{id}` returns available interactions on a resource instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the user to be deleted.
	@return ApiAvailableUserOperationsRequest
	*/
	AvailableUserOperations(ctx context.Context, id string) ApiAvailableUserOperationsRequest

	// AvailableUserOperationsExecute executes the request
	//  @return ResourceOptionsDto
	AvailableUserOperationsExecute(r ApiAvailableUserOperationsRequest) (*ResourceOptionsDto, *http.Response, error)

	/*
	CreateUser Create

	Create a new user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateUserRequest
	*/
	CreateUser(ctx context.Context) ApiCreateUserRequest

	// CreateUserExecute executes the request
	CreateUserExecute(r ApiCreateUserRequest) (*http.Response, error)

	/*
	DeleteUser Delete

	Deletes a user by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the user to be deleted.
	@return ApiDeleteUserRequest
	*/
	DeleteUser(ctx context.Context, id string) ApiDeleteUserRequest

	// DeleteUserExecute executes the request
	DeleteUserExecute(r ApiDeleteUserRequest) (*http.Response, error)

	/*
	GetUserCount Get List Count

	Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the
[Get Users](https://docs.camunda.org/manual/7.21/reference/rest/user/get-query/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserCountRequest
	*/
	GetUserCount(ctx context.Context) ApiGetUserCountRequest

	// GetUserCountExecute executes the request
	//  @return CountResultDto
	GetUserCountExecute(r ApiGetUserCountRequest) (*CountResultDto, *http.Response, error)

	/*
	GetUserProfile Get Profile

	Retrieves a user's profile.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the user to retrieve.
	@return ApiGetUserProfileRequest
	*/
	GetUserProfile(ctx context.Context, id string) ApiGetUserProfileRequest

	// GetUserProfileExecute executes the request
	//  @return UserProfileDto
	GetUserProfileExecute(r ApiGetUserProfileRequest) (*UserProfileDto, *http.Response, error)

	/*
	GetUsers Get List

	Query for a list of users using a list of parameters.
The size of the result set can be retrieved by using the Get User Count method.
[Get User Count](https://docs.camunda.org/manual/7.21/reference/rest/user/get-query-count/) method.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUsersRequest
	*/
	GetUsers(ctx context.Context) ApiGetUsersRequest

	// GetUsersExecute executes the request
	//  @return []UserProfileDto
	GetUsersExecute(r ApiGetUsersRequest) ([]UserProfileDto, *http.Response, error)

	/*
	UnlockUser Unlock User

	Unlocks a user by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the user to be unlocked.
	@return ApiUnlockUserRequest
	*/
	UnlockUser(ctx context.Context, id string) ApiUnlockUserRequest

	// UnlockUserExecute executes the request
	UnlockUserExecute(r ApiUnlockUserRequest) (*http.Response, error)

	/*
	UpdateCredentials Update Credentials

	Updates a user's credentials (password)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the user to be updated.
	@return ApiUpdateCredentialsRequest
	*/
	UpdateCredentials(ctx context.Context, id string) ApiUpdateCredentialsRequest

	// UpdateCredentialsExecute executes the request
	UpdateCredentialsExecute(r ApiUpdateCredentialsRequest) (*http.Response, error)

	/*
	UpdateProfile Update User Profile

	Updates the profile information of an already existing user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the user.
	@return ApiUpdateProfileRequest
	*/
	UpdateProfile(ctx context.Context, id string) ApiUpdateProfileRequest

	// UpdateProfileExecute executes the request
	UpdateProfileExecute(r ApiUpdateProfileRequest) (*http.Response, error)
}

// UserAPIService UserAPI service
type UserAPIService service

type ApiAvailableOperationsRequest struct {
	ctx context.Context
	ApiService UserAPI
}

func (r ApiAvailableOperationsRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.AvailableOperationsExecute(r)
}

/*
AvailableOperations Options

The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such
and one for individual user instances. The `OPTIONS` request allows checking for the set of
available operations that the currently authenticated user can perform on the /user resource.
If the user can perform an operation or not may depend on various things, including the user's
authorizations to interact with this resource and the internal configuration of the process
engine. `OPTIONS /user` returns available interactions on the resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAvailableOperationsRequest
*/
func (a *UserAPIService) AvailableOperations(ctx context.Context) ApiAvailableOperationsRequest {
	return ApiAvailableOperationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *UserAPIService) AvailableOperationsExecute(r ApiAvailableOperationsRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.AvailableOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAvailableUserOperationsRequest struct {
	ctx context.Context
	ApiService UserAPI
	id string
}

func (r ApiAvailableUserOperationsRequest) Execute() (*ResourceOptionsDto, *http.Response, error) {
	return r.ApiService.AvailableUserOperationsExecute(r)
}

/*
AvailableUserOperations Options

The `/user` resource supports two custom `OPTIONS` requests, one for the resource as such
and one for individual user instances. The `OPTIONS` request allows checking for the set of
available operations that the currently authenticated user can perform on the /user resource.
If the user can perform an operation or not may depend on various things, including the user's
authorizations to interact with this resource and the internal configuration of the process
engine. `OPTIONS /user/{id}` returns available interactions on a resource instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the user to be deleted.
 @return ApiAvailableUserOperationsRequest
*/
func (a *UserAPIService) AvailableUserOperations(ctx context.Context, id string) ApiAvailableUserOperationsRequest {
	return ApiAvailableUserOperationsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceOptionsDto
func (a *UserAPIService) AvailableUserOperationsExecute(r ApiAvailableUserOperationsRequest) (*ResourceOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.AvailableUserOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserRequest struct {
	ctx context.Context
	ApiService UserAPI
	userDto *UserDto
}

func (r ApiCreateUserRequest) UserDto(userDto UserDto) ApiCreateUserRequest {
	r.userDto = &userDto
	return r
}

func (r ApiCreateUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateUserExecute(r)
}

/*
CreateUser Create

Create a new user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUserRequest
*/
func (a *UserAPIService) CreateUser(ctx context.Context) ApiCreateUserRequest {
	return ApiCreateUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserAPIService) CreateUserExecute(r ApiCreateUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.CreateUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUserRequest struct {
	ctx context.Context
	ApiService UserAPI
	id string
}

func (r ApiDeleteUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserExecute(r)
}

/*
DeleteUser Delete

Deletes a user by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the user to be deleted.
 @return ApiDeleteUserRequest
*/
func (a *UserAPIService) DeleteUser(ctx context.Context, id string) ApiDeleteUserRequest {
	return ApiDeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserAPIService) DeleteUserExecute(r ApiDeleteUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.DeleteUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUserCountRequest struct {
	ctx context.Context
	ApiService UserAPI
	id *string
	idIn *string
	firstName *string
	firstNameLike *string
	lastName *string
	lastNameLike *string
	email *string
	emailLike *string
	memberOfGroup *string
	memberOfTenant *string
	potentialStarter *string
}

// Filter by user id
func (r ApiGetUserCountRequest) Id(id string) ApiGetUserCountRequest {
	r.id = &id
	return r
}

// Filter by a comma-separated list of user ids.
func (r ApiGetUserCountRequest) IdIn(idIn string) ApiGetUserCountRequest {
	r.idIn = &idIn
	return r
}

// Filter by the first name of the user. Exact match.
func (r ApiGetUserCountRequest) FirstName(firstName string) ApiGetUserCountRequest {
	r.firstName = &firstName
	return r
}

// Filter by the first name that the parameter is a substring of.
func (r ApiGetUserCountRequest) FirstNameLike(firstNameLike string) ApiGetUserCountRequest {
	r.firstNameLike = &firstNameLike
	return r
}

// Filter by the last name of the user. Exact match.
func (r ApiGetUserCountRequest) LastName(lastName string) ApiGetUserCountRequest {
	r.lastName = &lastName
	return r
}

// Filter by the last name that the parameter is a substring of.
func (r ApiGetUserCountRequest) LastNameLike(lastNameLike string) ApiGetUserCountRequest {
	r.lastNameLike = &lastNameLike
	return r
}

// Filter by the email of the user. Exact match.
func (r ApiGetUserCountRequest) Email(email string) ApiGetUserCountRequest {
	r.email = &email
	return r
}

// Filter by the email that the parameter is a substring of.
func (r ApiGetUserCountRequest) EmailLike(emailLike string) ApiGetUserCountRequest {
	r.emailLike = &emailLike
	return r
}

// Filter for users which are members of the given group.
func (r ApiGetUserCountRequest) MemberOfGroup(memberOfGroup string) ApiGetUserCountRequest {
	r.memberOfGroup = &memberOfGroup
	return r
}

// Filter for users which are members of the given tenant.
func (r ApiGetUserCountRequest) MemberOfTenant(memberOfTenant string) ApiGetUserCountRequest {
	r.memberOfTenant = &memberOfTenant
	return r
}

// Only select Users that are potential starter for the given process definition.
func (r ApiGetUserCountRequest) PotentialStarter(potentialStarter string) ApiGetUserCountRequest {
	r.potentialStarter = &potentialStarter
	return r
}

func (r ApiGetUserCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetUserCountExecute(r)
}

/*
GetUserCount Get List Count

Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the
[Get Users](https://docs.camunda.org/manual/7.21/reference/rest/user/get-query/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserCountRequest
*/
func (a *UserAPIService) GetUserCount(ctx context.Context) ApiGetUserCountRequest {
	return ApiGetUserCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *UserAPIService) GetUserCountExecute(r ApiGetUserCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetUserCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idIn", r.idIn, "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.firstNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstNameLike", r.firstNameLike, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.lastNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastNameLike", r.lastNameLike, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.emailLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailLike", r.emailLike, "")
	}
	if r.memberOfGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "memberOfGroup", r.memberOfGroup, "")
	}
	if r.memberOfTenant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "memberOfTenant", r.memberOfTenant, "")
	}
	if r.potentialStarter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "potentialStarter", r.potentialStarter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserProfileRequest struct {
	ctx context.Context
	ApiService UserAPI
	id string
}

func (r ApiGetUserProfileRequest) Execute() (*UserProfileDto, *http.Response, error) {
	return r.ApiService.GetUserProfileExecute(r)
}

/*
GetUserProfile Get Profile

Retrieves a user's profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the user to retrieve.
 @return ApiGetUserProfileRequest
*/
func (a *UserAPIService) GetUserProfile(ctx context.Context, id string) ApiGetUserProfileRequest {
	return ApiGetUserProfileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UserProfileDto
func (a *UserAPIService) GetUserProfileExecute(r ApiGetUserProfileRequest) (*UserProfileDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserProfileDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetUserProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/{id}/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersRequest struct {
	ctx context.Context
	ApiService UserAPI
	id *string
	idIn *string
	firstName *string
	firstNameLike *string
	lastName *string
	lastNameLike *string
	email *string
	emailLike *string
	memberOfGroup *string
	memberOfTenant *string
	potentialStarter *string
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Filter by user id
func (r ApiGetUsersRequest) Id(id string) ApiGetUsersRequest {
	r.id = &id
	return r
}

// Filter by a comma-separated list of user ids.
func (r ApiGetUsersRequest) IdIn(idIn string) ApiGetUsersRequest {
	r.idIn = &idIn
	return r
}

// Filter by the first name of the user. Exact match.
func (r ApiGetUsersRequest) FirstName(firstName string) ApiGetUsersRequest {
	r.firstName = &firstName
	return r
}

// Filter by the first name that the parameter is a substring of.
func (r ApiGetUsersRequest) FirstNameLike(firstNameLike string) ApiGetUsersRequest {
	r.firstNameLike = &firstNameLike
	return r
}

// Filter by the last name of the user. Exact match.
func (r ApiGetUsersRequest) LastName(lastName string) ApiGetUsersRequest {
	r.lastName = &lastName
	return r
}

// Filter by the last name that the parameter is a substring of.
func (r ApiGetUsersRequest) LastNameLike(lastNameLike string) ApiGetUsersRequest {
	r.lastNameLike = &lastNameLike
	return r
}

// Filter by the email of the user. Exact match.
func (r ApiGetUsersRequest) Email(email string) ApiGetUsersRequest {
	r.email = &email
	return r
}

// Filter by the email that the parameter is a substring of.
func (r ApiGetUsersRequest) EmailLike(emailLike string) ApiGetUsersRequest {
	r.emailLike = &emailLike
	return r
}

// Filter for users which are members of the given group.
func (r ApiGetUsersRequest) MemberOfGroup(memberOfGroup string) ApiGetUsersRequest {
	r.memberOfGroup = &memberOfGroup
	return r
}

// Filter for users which are members of the given tenant.
func (r ApiGetUsersRequest) MemberOfTenant(memberOfTenant string) ApiGetUsersRequest {
	r.memberOfTenant = &memberOfTenant
	return r
}

// Only select Users that are potential starter for the given process definition.
func (r ApiGetUsersRequest) PotentialStarter(potentialStarter string) ApiGetUsersRequest {
	r.potentialStarter = &potentialStarter
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetUsersRequest) SortBy(sortBy string) ApiGetUsersRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetUsersRequest) SortOrder(sortOrder string) ApiGetUsersRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetUsersRequest) FirstResult(firstResult int32) ApiGetUsersRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetUsersRequest) MaxResults(maxResults int32) ApiGetUsersRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetUsersRequest) Execute() ([]UserProfileDto, *http.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
GetUsers Get List

Query for a list of users using a list of parameters.
The size of the result set can be retrieved by using the Get User Count method.
[Get User Count](https://docs.camunda.org/manual/7.21/reference/rest/user/get-query-count/) method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsersRequest
*/
func (a *UserAPIService) GetUsers(ctx context.Context) ApiGetUsersRequest {
	return ApiGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UserProfileDto
func (a *UserAPIService) GetUsersExecute(r ApiGetUsersRequest) ([]UserProfileDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserProfileDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idIn", r.idIn, "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.firstNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstNameLike", r.firstNameLike, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	if r.lastNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastNameLike", r.lastNameLike, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.emailLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailLike", r.emailLike, "")
	}
	if r.memberOfGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "memberOfGroup", r.memberOfGroup, "")
	}
	if r.memberOfTenant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "memberOfTenant", r.memberOfTenant, "")
	}
	if r.potentialStarter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "potentialStarter", r.potentialStarter, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnlockUserRequest struct {
	ctx context.Context
	ApiService UserAPI
	id string
}

func (r ApiUnlockUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnlockUserExecute(r)
}

/*
UnlockUser Unlock User

Unlocks a user by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the user to be unlocked.
 @return ApiUnlockUserRequest
*/
func (a *UserAPIService) UnlockUser(ctx context.Context, id string) ApiUnlockUserRequest {
	return ApiUnlockUserRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserAPIService) UnlockUserExecute(r ApiUnlockUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UnlockUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/{id}/unlock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCredentialsRequest struct {
	ctx context.Context
	ApiService UserAPI
	id string
	userCredentialsDto *UserCredentialsDto
}

func (r ApiUpdateCredentialsRequest) UserCredentialsDto(userCredentialsDto UserCredentialsDto) ApiUpdateCredentialsRequest {
	r.userCredentialsDto = &userCredentialsDto
	return r
}

func (r ApiUpdateCredentialsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCredentialsExecute(r)
}

/*
UpdateCredentials Update Credentials

Updates a user's credentials (password)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the user to be updated.
 @return ApiUpdateCredentialsRequest
*/
func (a *UserAPIService) UpdateCredentials(ctx context.Context, id string) ApiUpdateCredentialsRequest {
	return ApiUpdateCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserAPIService) UpdateCredentialsExecute(r ApiUpdateCredentialsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UpdateCredentials")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/{id}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userCredentialsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateProfileRequest struct {
	ctx context.Context
	ApiService UserAPI
	id string
	userProfileDto *UserProfileDto
}

func (r ApiUpdateProfileRequest) UserProfileDto(userProfileDto UserProfileDto) ApiUpdateProfileRequest {
	r.userProfileDto = &userProfileDto
	return r
}

func (r ApiUpdateProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateProfileExecute(r)
}

/*
UpdateProfile Update User Profile

Updates the profile information of an already existing user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the user.
 @return ApiUpdateProfileRequest
*/
func (a *UserAPIService) UpdateProfile(ctx context.Context, id string) ApiUpdateProfileRequest {
	return ApiUpdateProfileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *UserAPIService) UpdateProfileExecute(r ApiUpdateProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UpdateProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/{id}/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userProfileDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
