/*
Camunda Platform REST API

OpenApi Spec for Camunda Platform REST API.

API version: 7.21.2-ee
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package camundarestgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type TaskAPI interface {

	/*
	Claim Claim

	Claims a task for a specific user.

**Note:** The difference with the
[Set Assignee](https://docs.camunda.org/manual/7.21/reference/rest/task/post-assignee/)
method is that here a check is performed to see if the task already has a user
assigned to it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to claim.
	@return ApiClaimRequest
	*/
	Claim(ctx context.Context, id string) ApiClaimRequest

	// ClaimExecute executes the request
	ClaimExecute(r ApiClaimRequest) (*http.Response, error)

	/*
	Complete Complete

	Completes a task and updates process variables.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to complete.
	@return ApiCompleteRequest
	*/
	Complete(ctx context.Context, id string) ApiCompleteRequest

	// CompleteExecute executes the request
	//  @return map[string]VariableValueDto
	CompleteExecute(r ApiCompleteRequest) (*map[string]VariableValueDto, *http.Response, error)

	/*
	CreateTask Create

	Creates a new task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateTaskRequest
	*/
	CreateTask(ctx context.Context) ApiCreateTaskRequest

	// CreateTaskExecute executes the request
	CreateTaskExecute(r ApiCreateTaskRequest) (*http.Response, error)

	/*
	DelegateTask Delegate

	Delegates a task to another user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to delegate.
	@return ApiDelegateTaskRequest
	*/
	DelegateTask(ctx context.Context, id string) ApiDelegateTaskRequest

	// DelegateTaskExecute executes the request
	DelegateTaskExecute(r ApiDelegateTaskRequest) (*http.Response, error)

	/*
	DeleteTask Delete

	Removes a task by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to be removed.
	@return ApiDeleteTaskRequest
	*/
	DeleteTask(ctx context.Context, id string) ApiDeleteTaskRequest

	// DeleteTaskExecute executes the request
	DeleteTaskExecute(r ApiDeleteTaskRequest) (*http.Response, error)

	/*
	GetDeployedForm Get Deployed Form

	Retrieves the deployed form that is referenced from a given task. For further
information please refer to the
[User Guide](https://docs.camunda.org/manual/7.21/user-guide/task-forms/#embedded-task-forms).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to get the deployed form for.
	@return ApiGetDeployedFormRequest
	*/
	GetDeployedForm(ctx context.Context, id string) ApiGetDeployedFormRequest

	// GetDeployedFormExecute executes the request
	//  @return *os.File
	GetDeployedFormExecute(r ApiGetDeployedFormRequest) (*os.File, *http.Response, error)

	/*
	GetForm Get Form Key

	Retrieves the form key for a task. The form key corresponds to the `FormData#formKey`
property in the engine. This key can be used to do task-specific form rendering in
client applications. Additionally, the context path of the containing process
application is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to retrieve the form for.
	@return ApiGetFormRequest
	*/
	GetForm(ctx context.Context, id string) ApiGetFormRequest

	// GetFormExecute executes the request
	//  @return FormDto
	GetFormExecute(r ApiGetFormRequest) (*FormDto, *http.Response, error)

	/*
	GetFormVariables Get Task Form Variables

	Retrieves the form variables for a task. The form variables take form data specified
on the task into account. If form fields are defined, the variable types and default
values of the form fields are taken into account.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to retrieve the variables for.
	@return ApiGetFormVariablesRequest
	*/
	GetFormVariables(ctx context.Context, id string) ApiGetFormVariablesRequest

	// GetFormVariablesExecute executes the request
	//  @return map[string]VariableValueDto
	GetFormVariablesExecute(r ApiGetFormVariablesRequest) (*map[string]VariableValueDto, *http.Response, error)

	/*
	GetRenderedForm Get Rendered Form

	Retrieves the rendered form for a task. This method can be used to get the HTML
rendering of a
[Generated Task Form](https://docs.camunda.org/manual/7.21/user-guide/task-forms/#generated-task-forms).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to get the rendered form for.
	@return ApiGetRenderedFormRequest
	*/
	GetRenderedForm(ctx context.Context, id string) ApiGetRenderedFormRequest

	// GetRenderedFormExecute executes the request
	//  @return *os.File
	GetRenderedFormExecute(r ApiGetRenderedFormRequest) (*os.File, *http.Response, error)

	/*
	GetTask Get

	Retrieves a task by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to be retrieved.
	@return ApiGetTaskRequest
	*/
	GetTask(ctx context.Context, id string) ApiGetTaskRequest

	// GetTaskExecute executes the request
	//  @return TaskDto
	GetTaskExecute(r ApiGetTaskRequest) (*TaskDto, *http.Response, error)

	/*
	GetTaskCountByCandidateGroup Get Task Count By Candidate Group

	Retrieves the number of tasks for each candidate group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTaskCountByCandidateGroupRequest
	*/
	GetTaskCountByCandidateGroup(ctx context.Context) ApiGetTaskCountByCandidateGroupRequest

	// GetTaskCountByCandidateGroupExecute executes the request
	//  @return []TaskCountByCandidateGroupResultDto
	GetTaskCountByCandidateGroupExecute(r ApiGetTaskCountByCandidateGroupRequest) ([]TaskCountByCandidateGroupResultDto, *http.Response, error)

	/*
	GetTasks Get List

	Queries for tasks that fulfill a given filter. The size of the result set can be
retrieved by using the Get Task Count method.

**Security Consideration:** There are several query parameters (such as
assigneeExpression) for specifying an EL expression. These are disabled by default to
prevent remote code execution. See the section on
[security considerations](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/)
for custom code in the user guide for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTasksRequest
	*/
	GetTasks(ctx context.Context) ApiGetTasksRequest

	// GetTasksExecute executes the request
	//  @return []TaskDto
	GetTasksExecute(r ApiGetTasksRequest) ([]TaskDto, *http.Response, error)

	/*
	GetTasksCount Get List Count

	Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size
of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.21/reference/rest/task/) method.

**Security Consideration:** There are several query parameters (such as
assigneeExpression) for specifying an EL expression. These are disabled by default to
prevent remote code execution. See the section on
[security considerations](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/)
for custom code in the user guide for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTasksCountRequest
	*/
	GetTasksCount(ctx context.Context) ApiGetTasksCountRequest

	// GetTasksCountExecute executes the request
	//  @return CountResultDto
	GetTasksCountExecute(r ApiGetTasksCountRequest) (*CountResultDto, *http.Response, error)

	/*
	HandleBpmnError Handle BPMN Error

	Reports a business error in the context of a running task by id. The error code must
be specified to identify the BPMN error handler. See the documentation for
[Reporting Bpmn Error](https://docs.camunda.org/manual/7.21/reference/bpmn20/tasks/user-task/#reporting-bpmn-error)
in User Tasks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task a BPMN error is reported for.
	@return ApiHandleBpmnErrorRequest
	*/
	HandleBpmnError(ctx context.Context, id string) ApiHandleBpmnErrorRequest

	// HandleBpmnErrorExecute executes the request
	HandleBpmnErrorExecute(r ApiHandleBpmnErrorRequest) (*http.Response, error)

	/*
	HandleEscalation Handle BPMN Escalation

	Reports an escalation in the context of a running task by id. The escalation code must
be specified to identify the escalation handler. See the documentation for
[Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.21/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation)
in User Tasks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task in which context a BPMN escalation is reported.
	@return ApiHandleEscalationRequest
	*/
	HandleEscalation(ctx context.Context, id string) ApiHandleEscalationRequest

	// HandleEscalationExecute executes the request
	HandleEscalationExecute(r ApiHandleEscalationRequest) (*http.Response, error)

	/*
	QueryTasks Get List (POST)

	Queries for tasks that fulfill a given filter. This method is slightly more powerful
than the [Get Tasks](https://docs.camunda.org/manual/7.21/reference/rest/task/get-query/) method because it
allows filtering by multiple process or task variables of types `String`, `Number`
or `Boolean`. The size of the result set can be retrieved by using the
[Get Task Count (POST)](https://docs.camunda.org/manual/7.21/reference/rest/task/post-query-count/) method.

**Security Consideration**:
There are several parameters (such as `assigneeExpression`) for specifying an EL
expression. These are disabled by default to prevent remote code execution. See the
section on
[security considerations for custom code](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/)
in the user guide for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryTasksRequest
	*/
	QueryTasks(ctx context.Context) ApiQueryTasksRequest

	// QueryTasksExecute executes the request
	//  @return []TaskDto
	QueryTasksExecute(r ApiQueryTasksRequest) ([]TaskDto, *http.Response, error)

	/*
	QueryTasksCount Get List Count (POST)

	Retrieves the number of tasks that fulfill the given filter. Corresponds to the size
of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.21/reference/rest/task/post-query/)
method and takes the same parameters.

**Security Consideration**:
There are several parameters (such as `assigneeExpression`) for specifying an EL
expression. These are disabled by default to prevent remote code execution. See the
section on
[security considerations for custom code](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/)
in the user guide for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryTasksCountRequest
	*/
	QueryTasksCount(ctx context.Context) ApiQueryTasksCountRequest

	// QueryTasksCountExecute executes the request
	//  @return CountResultDto
	QueryTasksCountExecute(r ApiQueryTasksCountRequest) (*CountResultDto, *http.Response, error)

	/*
	Resolve Resolve

	Resolves a task and updates execution variables.

Resolving a task marks that the assignee is done with the task delegated to them, and
that it can be sent back to the owner. Can only be executed when the task has been
delegated. The assignee will be set to the owner, who performed the delegation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to resolve.
	@return ApiResolveRequest
	*/
	Resolve(ctx context.Context, id string) ApiResolveRequest

	// ResolveExecute executes the request
	ResolveExecute(r ApiResolveRequest) (*http.Response, error)

	/*
	SetAssignee Set Assignee

	Changes the assignee of a task to a specific user.

**Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.21/reference/rest/task/post-claim/)
method is that this method does not check if the task already has a user
assigned to it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to set the assignee for.
	@return ApiSetAssigneeRequest
	*/
	SetAssignee(ctx context.Context, id string) ApiSetAssigneeRequest

	// SetAssigneeExecute executes the request
	SetAssigneeExecute(r ApiSetAssigneeRequest) (*http.Response, error)

	/*
	Submit Submit Form

	Completes a task and updates process variables using a form submit. There are two
difference between this method and the `complete` method:

* If the task is in state `PENDING` - i.e., has been delegated before, it is not
completed but resolved. Otherwise it will be completed.
* If the task has Form Field Metadata defined, the process engine will perform backend
validation for any form fields which have validators defined.
See the
[Generated Task Forms](https://docs.camunda.org/manual/7.21/user-guide/task-forms/_index/#generated-task-forms)
section of the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/) for more information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to submit the form for.
	@return ApiSubmitRequest
	*/
	Submit(ctx context.Context, id string) ApiSubmitRequest

	// SubmitExecute executes the request
	//  @return map[string]VariableValueDto
	SubmitExecute(r ApiSubmitRequest) (*map[string]VariableValueDto, *http.Response, error)

	/*
	Unclaim Unclaim

	Resets a task's assignee. If successful, the task is not assigned to a user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to unclaim.
	@return ApiUnclaimRequest
	*/
	Unclaim(ctx context.Context, id string) ApiUnclaimRequest

	// UnclaimExecute executes the request
	UnclaimExecute(r ApiUnclaimRequest) (*http.Response, error)

	/*
	UpdateTask Update

	Updates a task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The id of the task to be updated.
	@return ApiUpdateTaskRequest
	*/
	UpdateTask(ctx context.Context, id string) ApiUpdateTaskRequest

	// UpdateTaskExecute executes the request
	UpdateTaskExecute(r ApiUpdateTaskRequest) (*http.Response, error)
}

// TaskAPIService TaskAPI service
type TaskAPIService service

type ApiClaimRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	userIdDto *UserIdDto
}

// Provide the id of the user that claims the task.
func (r ApiClaimRequest) UserIdDto(userIdDto UserIdDto) ApiClaimRequest {
	r.userIdDto = &userIdDto
	return r
}

func (r ApiClaimRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClaimExecute(r)
}

/*
Claim Claim

Claims a task for a specific user.

**Note:** The difference with the
[Set Assignee](https://docs.camunda.org/manual/7.21/reference/rest/task/post-assignee/)
method is that here a check is performed to see if the task already has a user
assigned to it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to claim.
 @return ApiClaimRequest
*/
func (a *TaskAPIService) Claim(ctx context.Context, id string) ApiClaimRequest {
	return ApiClaimRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) ClaimExecute(r ApiClaimRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Claim")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/claim"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userIdDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompleteRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	completeTaskDto *CompleteTaskDto
}

func (r ApiCompleteRequest) CompleteTaskDto(completeTaskDto CompleteTaskDto) ApiCompleteRequest {
	r.completeTaskDto = &completeTaskDto
	return r
}

func (r ApiCompleteRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.CompleteExecute(r)
}

/*
Complete Complete

Completes a task and updates process variables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to complete.
 @return ApiCompleteRequest
*/
func (a *TaskAPIService) Complete(ctx context.Context, id string) ApiCompleteRequest {
	return ApiCompleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]VariableValueDto
func (a *TaskAPIService) CompleteExecute(r ApiCompleteRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Complete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/complete"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.completeTaskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTaskRequest struct {
	ctx context.Context
	ApiService TaskAPI
	taskDto *TaskDto
}

func (r ApiCreateTaskRequest) TaskDto(taskDto TaskDto) ApiCreateTaskRequest {
	r.taskDto = &taskDto
	return r
}

func (r ApiCreateTaskRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateTaskExecute(r)
}

/*
CreateTask Create

Creates a new task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTaskRequest
*/
func (a *TaskAPIService) CreateTask(ctx context.Context) ApiCreateTaskRequest {
	return ApiCreateTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TaskAPIService) CreateTaskExecute(r ApiCreateTaskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.CreateTask")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDelegateTaskRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	userIdDto *UserIdDto
}

// Provide the id of the user that the task should be delegated to.
func (r ApiDelegateTaskRequest) UserIdDto(userIdDto UserIdDto) ApiDelegateTaskRequest {
	r.userIdDto = &userIdDto
	return r
}

func (r ApiDelegateTaskRequest) Execute() (*http.Response, error) {
	return r.ApiService.DelegateTaskExecute(r)
}

/*
DelegateTask Delegate

Delegates a task to another user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to delegate.
 @return ApiDelegateTaskRequest
*/
func (a *TaskAPIService) DelegateTask(ctx context.Context, id string) ApiDelegateTaskRequest {
	return ApiDelegateTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) DelegateTaskExecute(r ApiDelegateTaskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.DelegateTask")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/delegate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userIdDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTaskRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
}

func (r ApiDeleteTaskRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTaskExecute(r)
}

/*
DeleteTask Delete

Removes a task by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to be removed.
 @return ApiDeleteTaskRequest
*/
func (a *TaskAPIService) DeleteTask(ctx context.Context, id string) ApiDeleteTaskRequest {
	return ApiDeleteTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) DeleteTaskExecute(r ApiDeleteTaskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.DeleteTask")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeployedFormRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
}

func (r ApiGetDeployedFormRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetDeployedFormExecute(r)
}

/*
GetDeployedForm Get Deployed Form

Retrieves the deployed form that is referenced from a given task. For further
information please refer to the
[User Guide](https://docs.camunda.org/manual/7.21/user-guide/task-forms/#embedded-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to get the deployed form for.
 @return ApiGetDeployedFormRequest
*/
func (a *TaskAPIService) GetDeployedForm(ctx context.Context, id string) ApiGetDeployedFormRequest {
	return ApiGetDeployedFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TaskAPIService) GetDeployedFormExecute(r ApiGetDeployedFormRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetDeployedForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/deployed-form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFormRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
}

func (r ApiGetFormRequest) Execute() (*FormDto, *http.Response, error) {
	return r.ApiService.GetFormExecute(r)
}

/*
GetForm Get Form Key

Retrieves the form key for a task. The form key corresponds to the `FormData#formKey`
property in the engine. This key can be used to do task-specific form rendering in
client applications. Additionally, the context path of the containing process
application is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to retrieve the form for.
 @return ApiGetFormRequest
*/
func (a *TaskAPIService) GetForm(ctx context.Context, id string) ApiGetFormRequest {
	return ApiGetFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FormDto
func (a *TaskAPIService) GetFormExecute(r ApiGetFormRequest) (*FormDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FormDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFormVariablesRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	variableNames *string
	deserializeValues *bool
}

// A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
func (r ApiGetFormVariablesRequest) VariableNames(variableNames string) ApiGetFormVariablesRequest {
	r.variableNames = &variableNames
	return r
}

// Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
func (r ApiGetFormVariablesRequest) DeserializeValues(deserializeValues bool) ApiGetFormVariablesRequest {
	r.deserializeValues = &deserializeValues
	return r
}

func (r ApiGetFormVariablesRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.GetFormVariablesExecute(r)
}

/*
GetFormVariables Get Task Form Variables

Retrieves the form variables for a task. The form variables take form data specified
on the task into account. If form fields are defined, the variable types and default
values of the form fields are taken into account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to retrieve the variables for.
 @return ApiGetFormVariablesRequest
*/
func (a *TaskAPIService) GetFormVariables(ctx context.Context, id string) ApiGetFormVariablesRequest {
	return ApiGetFormVariablesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]VariableValueDto
func (a *TaskAPIService) GetFormVariablesExecute(r ApiGetFormVariablesRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetFormVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/form-variables"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.variableNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNames", r.variableNames, "")
	}
	if r.deserializeValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deserializeValues", r.deserializeValues, "")
	} else {
		var defaultValue bool = true
		r.deserializeValues = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRenderedFormRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
}

func (r ApiGetRenderedFormRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetRenderedFormExecute(r)
}

/*
GetRenderedForm Get Rendered Form

Retrieves the rendered form for a task. This method can be used to get the HTML
rendering of a
[Generated Task Form](https://docs.camunda.org/manual/7.21/user-guide/task-forms/#generated-task-forms).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to get the rendered form for.
 @return ApiGetRenderedFormRequest
*/
func (a *TaskAPIService) GetRenderedForm(ctx context.Context, id string) ApiGetRenderedFormRequest {
	return ApiGetRenderedFormRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TaskAPIService) GetRenderedFormExecute(r ApiGetRenderedFormRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetRenderedForm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/rendered-form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xhtml+xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaskRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
}

func (r ApiGetTaskRequest) Execute() (*TaskDto, *http.Response, error) {
	return r.ApiService.GetTaskExecute(r)
}

/*
GetTask Get

Retrieves a task by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to be retrieved.
 @return ApiGetTaskRequest
*/
func (a *TaskAPIService) GetTask(ctx context.Context, id string) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TaskDto
func (a *TaskAPIService) GetTaskExecute(r ApiGetTaskRequest) (*TaskDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaskCountByCandidateGroupRequest struct {
	ctx context.Context
	ApiService TaskAPI
}

func (r ApiGetTaskCountByCandidateGroupRequest) Execute() ([]TaskCountByCandidateGroupResultDto, *http.Response, error) {
	return r.ApiService.GetTaskCountByCandidateGroupExecute(r)
}

/*
GetTaskCountByCandidateGroup Get Task Count By Candidate Group

Retrieves the number of tasks for each candidate group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTaskCountByCandidateGroupRequest
*/
func (a *TaskAPIService) GetTaskCountByCandidateGroup(ctx context.Context) ApiGetTaskCountByCandidateGroupRequest {
	return ApiGetTaskCountByCandidateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TaskCountByCandidateGroupResultDto
func (a *TaskAPIService) GetTaskCountByCandidateGroupExecute(r ApiGetTaskCountByCandidateGroupRequest) ([]TaskCountByCandidateGroupResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaskCountByCandidateGroupResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetTaskCountByCandidateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/report/candidate-group-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/csv", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTasksRequest struct {
	ctx context.Context
	ApiService TaskAPI
	taskId *string
	taskIdIn *string
	processInstanceId *string
	processInstanceIdIn *string
	processInstanceBusinessKey *string
	processInstanceBusinessKeyExpression *string
	processInstanceBusinessKeyIn *string
	processInstanceBusinessKeyLike *string
	processInstanceBusinessKeyLikeExpression *string
	processDefinitionId *string
	processDefinitionKey *string
	processDefinitionKeyIn *string
	processDefinitionName *string
	processDefinitionNameLike *string
	executionId *string
	caseInstanceId *string
	caseInstanceBusinessKey *string
	caseInstanceBusinessKeyLike *string
	caseDefinitionId *string
	caseDefinitionKey *string
	caseDefinitionName *string
	caseDefinitionNameLike *string
	caseExecutionId *string
	activityInstanceIdIn *string
	tenantIdIn *string
	withoutTenantId *bool
	assignee *string
	assigneeExpression *string
	assigneeLike *string
	assigneeLikeExpression *string
	assigneeIn *string
	assigneeNotIn *string
	owner *string
	ownerExpression *string
	candidateGroup *string
	candidateGroupExpression *string
	candidateUser *string
	candidateUserExpression *string
	includeAssignedTasks *bool
	involvedUser *string
	involvedUserExpression *string
	assigned *bool
	unassigned *bool
	taskDefinitionKey *string
	taskDefinitionKeyIn *string
	taskDefinitionKeyLike *string
	name *string
	nameNotEqual *string
	nameLike *string
	nameNotLike *string
	description *string
	descriptionLike *string
	priority *int32
	maxPriority *int32
	minPriority *int32
	dueDate *string
	dueDateExpression *string
	dueAfter *string
	dueAfterExpression *string
	dueBefore *string
	dueBeforeExpression *string
	withoutDueDate *bool
	followUpDate *string
	followUpDateExpression *string
	followUpAfter *string
	followUpAfterExpression *string
	followUpBefore *string
	followUpBeforeExpression *string
	followUpBeforeOrNotExistent *string
	followUpBeforeOrNotExistentExpression *string
	createdOn *string
	createdOnExpression *string
	createdAfter *string
	createdAfterExpression *string
	createdBefore *string
	createdBeforeExpression *string
	updatedAfter *string
	updatedAfterExpression *string
	delegationState *string
	candidateGroups *string
	candidateGroupsExpression *string
	withCandidateGroups *bool
	withoutCandidateGroups *bool
	withCandidateUsers *bool
	withoutCandidateUsers *bool
	active *bool
	suspended *bool
	taskVariables *string
	processVariables *string
	caseInstanceVariables *string
	variableNamesIgnoreCase *bool
	variableValuesIgnoreCase *bool
	parentTaskId *string
	sortBy *string
	sortOrder *string
	firstResult *int32
	maxResults *int32
}

// Restrict to task with the given id.
func (r ApiGetTasksRequest) TaskId(taskId string) ApiGetTasksRequest {
	r.taskId = &taskId
	return r
}

// Restrict to tasks with any of the given ids.
func (r ApiGetTasksRequest) TaskIdIn(taskIdIn string) ApiGetTasksRequest {
	r.taskIdIn = &taskIdIn
	return r
}

// Restrict to tasks that belong to process instances with the given id.
func (r ApiGetTasksRequest) ProcessInstanceId(processInstanceId string) ApiGetTasksRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Restrict to tasks that belong to process instances with the given ids.
func (r ApiGetTasksRequest) ProcessInstanceIdIn(processInstanceIdIn string) ApiGetTasksRequest {
	r.processInstanceIdIn = &processInstanceIdIn
	return r
}

// Restrict to tasks that belong to process instances with the given business key.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKey(processInstanceBusinessKey string) ApiGetTasksRequest {
	r.processInstanceBusinessKey = &processInstanceBusinessKey
	return r
}

// Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKeyExpression(processInstanceBusinessKeyExpression string) ApiGetTasksRequest {
	r.processInstanceBusinessKeyExpression = &processInstanceBusinessKeyExpression
	return r
}

// Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKeyIn(processInstanceBusinessKeyIn string) ApiGetTasksRequest {
	r.processInstanceBusinessKeyIn = &processInstanceBusinessKeyIn
	return r
}

// Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKeyLike(processInstanceBusinessKeyLike string) ApiGetTasksRequest {
	r.processInstanceBusinessKeyLike = &processInstanceBusinessKeyLike
	return r
}

// Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksRequest) ProcessInstanceBusinessKeyLikeExpression(processInstanceBusinessKeyLikeExpression string) ApiGetTasksRequest {
	r.processInstanceBusinessKeyLikeExpression = &processInstanceBusinessKeyLikeExpression
	return r
}

// Restrict to tasks that belong to a process definition with the given id.
func (r ApiGetTasksRequest) ProcessDefinitionId(processDefinitionId string) ApiGetTasksRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Restrict to tasks that belong to a process definition with the given key.
func (r ApiGetTasksRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetTasksRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
func (r ApiGetTasksRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetTasksRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restrict to tasks that belong to a process definition with the given name.
func (r ApiGetTasksRequest) ProcessDefinitionName(processDefinitionName string) ApiGetTasksRequest {
	r.processDefinitionName = &processDefinitionName
	return r
}

// Restrict to tasks that have a process definition name that has the parameter value as  a substring.
func (r ApiGetTasksRequest) ProcessDefinitionNameLike(processDefinitionNameLike string) ApiGetTasksRequest {
	r.processDefinitionNameLike = &processDefinitionNameLike
	return r
}

// Restrict to tasks that belong to an execution with the given id.
func (r ApiGetTasksRequest) ExecutionId(executionId string) ApiGetTasksRequest {
	r.executionId = &executionId
	return r
}

// Restrict to tasks that belong to case instances with the given id.
func (r ApiGetTasksRequest) CaseInstanceId(caseInstanceId string) ApiGetTasksRequest {
	r.caseInstanceId = &caseInstanceId
	return r
}

// Restrict to tasks that belong to case instances with the given business key.
func (r ApiGetTasksRequest) CaseInstanceBusinessKey(caseInstanceBusinessKey string) ApiGetTasksRequest {
	r.caseInstanceBusinessKey = &caseInstanceBusinessKey
	return r
}

// Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
func (r ApiGetTasksRequest) CaseInstanceBusinessKeyLike(caseInstanceBusinessKeyLike string) ApiGetTasksRequest {
	r.caseInstanceBusinessKeyLike = &caseInstanceBusinessKeyLike
	return r
}

// Restrict to tasks that belong to a case definition with the given id.
func (r ApiGetTasksRequest) CaseDefinitionId(caseDefinitionId string) ApiGetTasksRequest {
	r.caseDefinitionId = &caseDefinitionId
	return r
}

// Restrict to tasks that belong to a case definition with the given key.
func (r ApiGetTasksRequest) CaseDefinitionKey(caseDefinitionKey string) ApiGetTasksRequest {
	r.caseDefinitionKey = &caseDefinitionKey
	return r
}

// Restrict to tasks that belong to a case definition with the given name.
func (r ApiGetTasksRequest) CaseDefinitionName(caseDefinitionName string) ApiGetTasksRequest {
	r.caseDefinitionName = &caseDefinitionName
	return r
}

// Restrict to tasks that have a case definition name that has the parameter value as a  substring.
func (r ApiGetTasksRequest) CaseDefinitionNameLike(caseDefinitionNameLike string) ApiGetTasksRequest {
	r.caseDefinitionNameLike = &caseDefinitionNameLike
	return r
}

// Restrict to tasks that belong to a case execution with the given id.
func (r ApiGetTasksRequest) CaseExecutionId(caseExecutionId string) ApiGetTasksRequest {
	r.caseExecutionId = &caseExecutionId
	return r
}

// Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
func (r ApiGetTasksRequest) ActivityInstanceIdIn(activityInstanceIdIn string) ApiGetTasksRequest {
	r.activityInstanceIdIn = &activityInstanceIdIn
	return r
}

// Only include tasks which belong to one of the passed and comma-separated  tenant ids.
func (r ApiGetTasksRequest) TenantIdIn(tenantIdIn string) ApiGetTasksRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithoutTenantId(withoutTenantId bool) ApiGetTasksRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Restrict to tasks that the given user is assigned to.
func (r ApiGetTasksRequest) Assignee(assignee string) ApiGetTasksRequest {
	r.assignee = &assignee
	return r
}

// Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksRequest) AssigneeExpression(assigneeExpression string) ApiGetTasksRequest {
	r.assigneeExpression = &assigneeExpression
	return r
}

// Restrict to tasks that have an assignee that has the parameter  value as a substring.
func (r ApiGetTasksRequest) AssigneeLike(assigneeLike string) ApiGetTasksRequest {
	r.assigneeLike = &assigneeLike
	return r
}

// Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksRequest) AssigneeLikeExpression(assigneeLikeExpression string) ApiGetTasksRequest {
	r.assigneeLikeExpression = &assigneeLikeExpression
	return r
}

// Only include tasks which are assigned to one of the passed and  comma-separated user ids.
func (r ApiGetTasksRequest) AssigneeIn(assigneeIn string) ApiGetTasksRequest {
	r.assigneeIn = &assigneeIn
	return r
}

// Only include tasks which are not assigned to one of the passed and comma-separated user ids.
func (r ApiGetTasksRequest) AssigneeNotIn(assigneeNotIn string) ApiGetTasksRequest {
	r.assigneeNotIn = &assigneeNotIn
	return r
}

// Restrict to tasks that the given user owns.
func (r ApiGetTasksRequest) Owner(owner string) ApiGetTasksRequest {
	r.owner = &owner
	return r
}

// Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksRequest) OwnerExpression(ownerExpression string) ApiGetTasksRequest {
	r.ownerExpression = &ownerExpression
	return r
}

// Only include tasks that are offered to the given group.
func (r ApiGetTasksRequest) CandidateGroup(candidateGroup string) ApiGetTasksRequest {
	r.candidateGroup = &candidateGroup
	return r
}

// Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksRequest) CandidateGroupExpression(candidateGroupExpression string) ApiGetTasksRequest {
	r.candidateGroupExpression = &candidateGroupExpression
	return r
}

// Only include tasks that are offered to the given user or to one of his groups.
func (r ApiGetTasksRequest) CandidateUser(candidateUser string) ApiGetTasksRequest {
	r.candidateUser = &candidateUser
	return r
}

// Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksRequest) CandidateUserExpression(candidateUserExpression string) ApiGetTasksRequest {
	r.candidateUserExpression = &candidateUserExpression
	return r
}

// Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
func (r ApiGetTasksRequest) IncludeAssignedTasks(includeAssignedTasks bool) ApiGetTasksRequest {
	r.includeAssignedTasks = &includeAssignedTasks
	return r
}

// Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
func (r ApiGetTasksRequest) InvolvedUser(involvedUser string) ApiGetTasksRequest {
	r.involvedUser = &involvedUser
	return r
}

// Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksRequest) InvolvedUserExpression(involvedUserExpression string) ApiGetTasksRequest {
	r.involvedUserExpression = &involvedUserExpression
	return r
}

// If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
func (r ApiGetTasksRequest) Assigned(assigned bool) ApiGetTasksRequest {
	r.assigned = &assigned
	return r
}

// If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
func (r ApiGetTasksRequest) Unassigned(unassigned bool) ApiGetTasksRequest {
	r.unassigned = &unassigned
	return r
}

// Restrict to tasks that have the given key.
func (r ApiGetTasksRequest) TaskDefinitionKey(taskDefinitionKey string) ApiGetTasksRequest {
	r.taskDefinitionKey = &taskDefinitionKey
	return r
}

// Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksRequest) TaskDefinitionKeyIn(taskDefinitionKeyIn string) ApiGetTasksRequest {
	r.taskDefinitionKeyIn = &taskDefinitionKeyIn
	return r
}

// Restrict to tasks that have a key that has the parameter value as a substring.
func (r ApiGetTasksRequest) TaskDefinitionKeyLike(taskDefinitionKeyLike string) ApiGetTasksRequest {
	r.taskDefinitionKeyLike = &taskDefinitionKeyLike
	return r
}

// Restrict to tasks that have the given name.
func (r ApiGetTasksRequest) Name(name string) ApiGetTasksRequest {
	r.name = &name
	return r
}

// Restrict to tasks that do not have the given name.
func (r ApiGetTasksRequest) NameNotEqual(nameNotEqual string) ApiGetTasksRequest {
	r.nameNotEqual = &nameNotEqual
	return r
}

// Restrict to tasks that have a name with the given parameter value as substring.
func (r ApiGetTasksRequest) NameLike(nameLike string) ApiGetTasksRequest {
	r.nameLike = &nameLike
	return r
}

// Restrict to tasks that do not have a name with the given parameter value as substring.
func (r ApiGetTasksRequest) NameNotLike(nameNotLike string) ApiGetTasksRequest {
	r.nameNotLike = &nameNotLike
	return r
}

// Restrict to tasks that have the given description.
func (r ApiGetTasksRequest) Description(description string) ApiGetTasksRequest {
	r.description = &description
	return r
}

// Restrict to tasks that have a description that has the parameter value as a substring.
func (r ApiGetTasksRequest) DescriptionLike(descriptionLike string) ApiGetTasksRequest {
	r.descriptionLike = &descriptionLike
	return r
}

// Restrict to tasks that have the given priority.
func (r ApiGetTasksRequest) Priority(priority int32) ApiGetTasksRequest {
	r.priority = &priority
	return r
}

// Restrict to tasks that have a lower or equal priority.
func (r ApiGetTasksRequest) MaxPriority(maxPriority int32) ApiGetTasksRequest {
	r.maxPriority = &maxPriority
	return r
}

// Restrict to tasks that have a higher or equal priority.
func (r ApiGetTasksRequest) MinPriority(minPriority int32) ApiGetTasksRequest {
	r.minPriority = &minPriority
	return r
}

// Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
func (r ApiGetTasksRequest) DueDate(dueDate string) ApiGetTasksRequest {
	r.dueDate = &dueDate
	return r
}

// Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) DueDateExpression(dueDateExpression string) ApiGetTasksRequest {
	r.dueDateExpression = &dueDateExpression
	return r
}

// Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
func (r ApiGetTasksRequest) DueAfter(dueAfter string) ApiGetTasksRequest {
	r.dueAfter = &dueAfter
	return r
}

// Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) DueAfterExpression(dueAfterExpression string) ApiGetTasksRequest {
	r.dueAfterExpression = &dueAfterExpression
	return r
}

// Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
func (r ApiGetTasksRequest) DueBefore(dueBefore string) ApiGetTasksRequest {
	r.dueBefore = &dueBefore
	return r
}

// Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) DueBeforeExpression(dueBeforeExpression string) ApiGetTasksRequest {
	r.dueBeforeExpression = &dueBeforeExpression
	return r
}

// Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithoutDueDate(withoutDueDate bool) ApiGetTasksRequest {
	r.withoutDueDate = &withoutDueDate
	return r
}

// Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
func (r ApiGetTasksRequest) FollowUpDate(followUpDate string) ApiGetTasksRequest {
	r.followUpDate = &followUpDate
	return r
}

// Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) FollowUpDateExpression(followUpDateExpression string) ApiGetTasksRequest {
	r.followUpDateExpression = &followUpDateExpression
	return r
}

// Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
func (r ApiGetTasksRequest) FollowUpAfter(followUpAfter string) ApiGetTasksRequest {
	r.followUpAfter = &followUpAfter
	return r
}

// Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) FollowUpAfterExpression(followUpAfterExpression string) ApiGetTasksRequest {
	r.followUpAfterExpression = &followUpAfterExpression
	return r
}

// Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
func (r ApiGetTasksRequest) FollowUpBefore(followUpBefore string) ApiGetTasksRequest {
	r.followUpBefore = &followUpBefore
	return r
}

// Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) FollowUpBeforeExpression(followUpBeforeExpression string) ApiGetTasksRequest {
	r.followUpBeforeExpression = &followUpBeforeExpression
	return r
}

// Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
func (r ApiGetTasksRequest) FollowUpBeforeOrNotExistent(followUpBeforeOrNotExistent string) ApiGetTasksRequest {
	r.followUpBeforeOrNotExistent = &followUpBeforeOrNotExistent
	return r
}

// Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) FollowUpBeforeOrNotExistentExpression(followUpBeforeOrNotExistentExpression string) ApiGetTasksRequest {
	r.followUpBeforeOrNotExistentExpression = &followUpBeforeOrNotExistentExpression
	return r
}

// Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
func (r ApiGetTasksRequest) CreatedOn(createdOn string) ApiGetTasksRequest {
	r.createdOn = &createdOn
	return r
}

// Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) CreatedOnExpression(createdOnExpression string) ApiGetTasksRequest {
	r.createdOnExpression = &createdOnExpression
	return r
}

// Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
func (r ApiGetTasksRequest) CreatedAfter(createdAfter string) ApiGetTasksRequest {
	r.createdAfter = &createdAfter
	return r
}

// Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) CreatedAfterExpression(createdAfterExpression string) ApiGetTasksRequest {
	r.createdAfterExpression = &createdAfterExpression
	return r
}

// Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
func (r ApiGetTasksRequest) CreatedBefore(createdBefore string) ApiGetTasksRequest {
	r.createdBefore = &createdBefore
	return r
}

// Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) CreatedBeforeExpression(createdBeforeExpression string) ApiGetTasksRequest {
	r.createdBeforeExpression = &createdBeforeExpression
	return r
}

// Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
func (r ApiGetTasksRequest) UpdatedAfter(updatedAfter string) ApiGetTasksRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksRequest) UpdatedAfterExpression(updatedAfterExpression string) ApiGetTasksRequest {
	r.updatedAfterExpression = &updatedAfterExpression
	return r
}

// Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
func (r ApiGetTasksRequest) DelegationState(delegationState string) ApiGetTasksRequest {
	r.delegationState = &delegationState
	return r
}

// Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
func (r ApiGetTasksRequest) CandidateGroups(candidateGroups string) ApiGetTasksRequest {
	r.candidateGroups = &candidateGroups
	return r
}

// Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
func (r ApiGetTasksRequest) CandidateGroupsExpression(candidateGroupsExpression string) ApiGetTasksRequest {
	r.candidateGroupsExpression = &candidateGroupsExpression
	return r
}

// Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithCandidateGroups(withCandidateGroups bool) ApiGetTasksRequest {
	r.withCandidateGroups = &withCandidateGroups
	return r
}

// Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithoutCandidateGroups(withoutCandidateGroups bool) ApiGetTasksRequest {
	r.withoutCandidateGroups = &withoutCandidateGroups
	return r
}

// Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithCandidateUsers(withCandidateUsers bool) ApiGetTasksRequest {
	r.withCandidateUsers = &withCandidateUsers
	return r
}

// Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) WithoutCandidateUsers(withoutCandidateUsers bool) ApiGetTasksRequest {
	r.withoutCandidateUsers = &withoutCandidateUsers
	return r
}

// Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) Active(active bool) ApiGetTasksRequest {
	r.active = &active
	return r
}

// Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksRequest) Suspended(suspended bool) ApiGetTasksRequest {
	r.suspended = &suspended
	return r
}

// Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksRequest) TaskVariables(taskVariables string) ApiGetTasksRequest {
	r.taskVariables = &taskVariables
	return r
}

// Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksRequest) ProcessVariables(processVariables string) ApiGetTasksRequest {
	r.processVariables = &processVariables
	return r
}

// Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksRequest) CaseInstanceVariables(caseInstanceVariables string) ApiGetTasksRequest {
	r.caseInstanceVariables = &caseInstanceVariables
	return r
}

// Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
func (r ApiGetTasksRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetTasksRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
func (r ApiGetTasksRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetTasksRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

// Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
func (r ApiGetTasksRequest) ParentTaskId(parentTaskId string) ApiGetTasksRequest {
	r.parentTaskId = &parentTaskId
	return r
}

// Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
func (r ApiGetTasksRequest) SortBy(sortBy string) ApiGetTasksRequest {
	r.sortBy = &sortBy
	return r
}

// Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
func (r ApiGetTasksRequest) SortOrder(sortOrder string) ApiGetTasksRequest {
	r.sortOrder = &sortOrder
	return r
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiGetTasksRequest) FirstResult(firstResult int32) ApiGetTasksRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiGetTasksRequest) MaxResults(maxResults int32) ApiGetTasksRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiGetTasksRequest) Execute() ([]TaskDto, *http.Response, error) {
	return r.ApiService.GetTasksExecute(r)
}

/*
GetTasks Get List

Queries for tasks that fulfill a given filter. The size of the result set can be
retrieved by using the Get Task Count method.

**Security Consideration:** There are several query parameters (such as
assigneeExpression) for specifying an EL expression. These are disabled by default to
prevent remote code execution. See the section on
[security considerations](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/)
for custom code in the user guide for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTasksRequest
*/
func (a *TaskAPIService) GetTasks(ctx context.Context) ApiGetTasksRequest {
	return ApiGetTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TaskDto
func (a *TaskAPIService) GetTasksExecute(r ApiGetTasksRequest) ([]TaskDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaskDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskId", r.taskId, "")
	}
	if r.taskIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskIdIn", r.taskIdIn, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIdIn", r.processInstanceIdIn, "")
	}
	if r.processInstanceBusinessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKey", r.processInstanceBusinessKey, "")
	}
	if r.processInstanceBusinessKeyExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyExpression", r.processInstanceBusinessKeyExpression, "")
	}
	if r.processInstanceBusinessKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyIn", r.processInstanceBusinessKeyIn, "")
	}
	if r.processInstanceBusinessKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyLike", r.processInstanceBusinessKeyLike, "")
	}
	if r.processInstanceBusinessKeyLikeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyLikeExpression", r.processInstanceBusinessKeyLikeExpression, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionName", r.processDefinitionName, "")
	}
	if r.processDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionNameLike", r.processDefinitionNameLike, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.caseInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceId", r.caseInstanceId, "")
	}
	if r.caseInstanceBusinessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceBusinessKey", r.caseInstanceBusinessKey, "")
	}
	if r.caseInstanceBusinessKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceBusinessKeyLike", r.caseInstanceBusinessKeyLike, "")
	}
	if r.caseDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionId", r.caseDefinitionId, "")
	}
	if r.caseDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionKey", r.caseDefinitionKey, "")
	}
	if r.caseDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionName", r.caseDefinitionName, "")
	}
	if r.caseDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionNameLike", r.caseDefinitionNameLike, "")
	}
	if r.caseExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseExecutionId", r.caseExecutionId, "")
	}
	if r.activityInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityInstanceIdIn", r.activityInstanceIdIn, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	} else {
		var defaultValue bool = false
		r.withoutTenantId = &defaultValue
	}
	if r.assignee != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignee", r.assignee, "")
	}
	if r.assigneeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeExpression", r.assigneeExpression, "")
	}
	if r.assigneeLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeLike", r.assigneeLike, "")
	}
	if r.assigneeLikeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeLikeExpression", r.assigneeLikeExpression, "")
	}
	if r.assigneeIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeIn", r.assigneeIn, "")
	}
	if r.assigneeNotIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeNotIn", r.assigneeNotIn, "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	}
	if r.ownerExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerExpression", r.ownerExpression, "")
	}
	if r.candidateGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroup", r.candidateGroup, "")
	}
	if r.candidateGroupExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupExpression", r.candidateGroupExpression, "")
	}
	if r.candidateUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateUser", r.candidateUser, "")
	}
	if r.candidateUserExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateUserExpression", r.candidateUserExpression, "")
	}
	if r.includeAssignedTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAssignedTasks", r.includeAssignedTasks, "")
	} else {
		var defaultValue bool = false
		r.includeAssignedTasks = &defaultValue
	}
	if r.involvedUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "involvedUser", r.involvedUser, "")
	}
	if r.involvedUserExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "involvedUserExpression", r.involvedUserExpression, "")
	}
	if r.assigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned", r.assigned, "")
	} else {
		var defaultValue bool = false
		r.assigned = &defaultValue
	}
	if r.unassigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unassigned", r.unassigned, "")
	} else {
		var defaultValue bool = false
		r.unassigned = &defaultValue
	}
	if r.taskDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKey", r.taskDefinitionKey, "")
	}
	if r.taskDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyIn", r.taskDefinitionKeyIn, "")
	}
	if r.taskDefinitionKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyLike", r.taskDefinitionKeyLike, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameNotEqual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameNotEqual", r.nameNotEqual, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.nameNotLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameNotLike", r.nameNotLike, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.descriptionLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionLike", r.descriptionLike, "")
	}
	if r.priority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority", r.priority, "")
	}
	if r.maxPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxPriority", r.maxPriority, "")
	}
	if r.minPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minPriority", r.minPriority, "")
	}
	if r.dueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDate", r.dueDate, "")
	}
	if r.dueDateExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDateExpression", r.dueDateExpression, "")
	}
	if r.dueAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueAfter", r.dueAfter, "")
	}
	if r.dueAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueAfterExpression", r.dueAfterExpression, "")
	}
	if r.dueBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueBefore", r.dueBefore, "")
	}
	if r.dueBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueBeforeExpression", r.dueBeforeExpression, "")
	}
	if r.withoutDueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutDueDate", r.withoutDueDate, "")
	} else {
		var defaultValue bool = false
		r.withoutDueDate = &defaultValue
	}
	if r.followUpDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDate", r.followUpDate, "")
	}
	if r.followUpDateExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDateExpression", r.followUpDateExpression, "")
	}
	if r.followUpAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpAfter", r.followUpAfter, "")
	}
	if r.followUpAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpAfterExpression", r.followUpAfterExpression, "")
	}
	if r.followUpBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBefore", r.followUpBefore, "")
	}
	if r.followUpBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeExpression", r.followUpBeforeExpression, "")
	}
	if r.followUpBeforeOrNotExistent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeOrNotExistent", r.followUpBeforeOrNotExistent, "")
	}
	if r.followUpBeforeOrNotExistentExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeOrNotExistentExpression", r.followUpBeforeOrNotExistentExpression, "")
	}
	if r.createdOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOn", r.createdOn, "")
	}
	if r.createdOnExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnExpression", r.createdOnExpression, "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfter", r.createdAfter, "")
	}
	if r.createdAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfterExpression", r.createdAfterExpression, "")
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "")
	}
	if r.createdBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBeforeExpression", r.createdBeforeExpression, "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "")
	}
	if r.updatedAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfterExpression", r.updatedAfterExpression, "")
	}
	if r.delegationState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delegationState", r.delegationState, "")
	}
	if r.candidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroups", r.candidateGroups, "")
	}
	if r.candidateGroupsExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupsExpression", r.candidateGroupsExpression, "")
	}
	if r.withCandidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCandidateGroups", r.withCandidateGroups, "")
	} else {
		var defaultValue bool = false
		r.withCandidateGroups = &defaultValue
	}
	if r.withoutCandidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutCandidateGroups", r.withoutCandidateGroups, "")
	} else {
		var defaultValue bool = false
		r.withoutCandidateGroups = &defaultValue
	}
	if r.withCandidateUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCandidateUsers", r.withCandidateUsers, "")
	} else {
		var defaultValue bool = false
		r.withCandidateUsers = &defaultValue
	}
	if r.withoutCandidateUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutCandidateUsers", r.withoutCandidateUsers, "")
	} else {
		var defaultValue bool = false
		r.withoutCandidateUsers = &defaultValue
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	} else {
		var defaultValue bool = false
		r.active = &defaultValue
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	} else {
		var defaultValue bool = false
		r.suspended = &defaultValue
	}
	if r.taskVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskVariables", r.taskVariables, "")
	}
	if r.processVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processVariables", r.processVariables, "")
	}
	if r.caseInstanceVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceVariables", r.caseInstanceVariables, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableNamesIgnoreCase = &defaultValue
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableValuesIgnoreCase = &defaultValue
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentTaskId", r.parentTaskId, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTasksCountRequest struct {
	ctx context.Context
	ApiService TaskAPI
	taskId *string
	taskIdIn *string
	processInstanceId *string
	processInstanceIdIn *string
	processInstanceBusinessKey *string
	processInstanceBusinessKeyExpression *string
	processInstanceBusinessKeyIn *string
	processInstanceBusinessKeyLike *string
	processInstanceBusinessKeyLikeExpression *string
	processDefinitionId *string
	processDefinitionKey *string
	processDefinitionKeyIn *string
	processDefinitionName *string
	processDefinitionNameLike *string
	executionId *string
	caseInstanceId *string
	caseInstanceBusinessKey *string
	caseInstanceBusinessKeyLike *string
	caseDefinitionId *string
	caseDefinitionKey *string
	caseDefinitionName *string
	caseDefinitionNameLike *string
	caseExecutionId *string
	activityInstanceIdIn *string
	tenantIdIn *string
	withoutTenantId *bool
	assignee *string
	assigneeExpression *string
	assigneeLike *string
	assigneeLikeExpression *string
	assigneeIn *string
	assigneeNotIn *string
	owner *string
	ownerExpression *string
	candidateGroup *string
	candidateGroupExpression *string
	candidateUser *string
	candidateUserExpression *string
	includeAssignedTasks *bool
	involvedUser *string
	involvedUserExpression *string
	assigned *bool
	unassigned *bool
	taskDefinitionKey *string
	taskDefinitionKeyIn *string
	taskDefinitionKeyLike *string
	name *string
	nameNotEqual *string
	nameLike *string
	nameNotLike *string
	description *string
	descriptionLike *string
	priority *int32
	maxPriority *int32
	minPriority *int32
	dueDate *string
	dueDateExpression *string
	dueAfter *string
	dueAfterExpression *string
	dueBefore *string
	dueBeforeExpression *string
	withoutDueDate *bool
	followUpDate *string
	followUpDateExpression *string
	followUpAfter *string
	followUpAfterExpression *string
	followUpBefore *string
	followUpBeforeExpression *string
	followUpBeforeOrNotExistent *string
	followUpBeforeOrNotExistentExpression *string
	createdOn *string
	createdOnExpression *string
	createdAfter *string
	createdAfterExpression *string
	createdBefore *string
	createdBeforeExpression *string
	updatedAfter *string
	updatedAfterExpression *string
	delegationState *string
	candidateGroups *string
	candidateGroupsExpression *string
	withCandidateGroups *bool
	withoutCandidateGroups *bool
	withCandidateUsers *bool
	withoutCandidateUsers *bool
	active *bool
	suspended *bool
	taskVariables *string
	processVariables *string
	caseInstanceVariables *string
	variableNamesIgnoreCase *bool
	variableValuesIgnoreCase *bool
	parentTaskId *string
}

// Restrict to task with the given id.
func (r ApiGetTasksCountRequest) TaskId(taskId string) ApiGetTasksCountRequest {
	r.taskId = &taskId
	return r
}

// Restrict to tasks with any of the given ids.
func (r ApiGetTasksCountRequest) TaskIdIn(taskIdIn string) ApiGetTasksCountRequest {
	r.taskIdIn = &taskIdIn
	return r
}

// Restrict to tasks that belong to process instances with the given id.
func (r ApiGetTasksCountRequest) ProcessInstanceId(processInstanceId string) ApiGetTasksCountRequest {
	r.processInstanceId = &processInstanceId
	return r
}

// Restrict to tasks that belong to process instances with the given ids.
func (r ApiGetTasksCountRequest) ProcessInstanceIdIn(processInstanceIdIn string) ApiGetTasksCountRequest {
	r.processInstanceIdIn = &processInstanceIdIn
	return r
}

// Restrict to tasks that belong to process instances with the given business key.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKey(processInstanceBusinessKey string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKey = &processInstanceBusinessKey
	return r
}

// Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKeyExpression(processInstanceBusinessKeyExpression string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKeyExpression = &processInstanceBusinessKeyExpression
	return r
}

// Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKeyIn(processInstanceBusinessKeyIn string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKeyIn = &processInstanceBusinessKeyIn
	return r
}

// Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKeyLike(processInstanceBusinessKeyLike string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKeyLike = &processInstanceBusinessKeyLike
	return r
}

// Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksCountRequest) ProcessInstanceBusinessKeyLikeExpression(processInstanceBusinessKeyLikeExpression string) ApiGetTasksCountRequest {
	r.processInstanceBusinessKeyLikeExpression = &processInstanceBusinessKeyLikeExpression
	return r
}

// Restrict to tasks that belong to a process definition with the given id.
func (r ApiGetTasksCountRequest) ProcessDefinitionId(processDefinitionId string) ApiGetTasksCountRequest {
	r.processDefinitionId = &processDefinitionId
	return r
}

// Restrict to tasks that belong to a process definition with the given key.
func (r ApiGetTasksCountRequest) ProcessDefinitionKey(processDefinitionKey string) ApiGetTasksCountRequest {
	r.processDefinitionKey = &processDefinitionKey
	return r
}

// Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
func (r ApiGetTasksCountRequest) ProcessDefinitionKeyIn(processDefinitionKeyIn string) ApiGetTasksCountRequest {
	r.processDefinitionKeyIn = &processDefinitionKeyIn
	return r
}

// Restrict to tasks that belong to a process definition with the given name.
func (r ApiGetTasksCountRequest) ProcessDefinitionName(processDefinitionName string) ApiGetTasksCountRequest {
	r.processDefinitionName = &processDefinitionName
	return r
}

// Restrict to tasks that have a process definition name that has the parameter value as  a substring.
func (r ApiGetTasksCountRequest) ProcessDefinitionNameLike(processDefinitionNameLike string) ApiGetTasksCountRequest {
	r.processDefinitionNameLike = &processDefinitionNameLike
	return r
}

// Restrict to tasks that belong to an execution with the given id.
func (r ApiGetTasksCountRequest) ExecutionId(executionId string) ApiGetTasksCountRequest {
	r.executionId = &executionId
	return r
}

// Restrict to tasks that belong to case instances with the given id.
func (r ApiGetTasksCountRequest) CaseInstanceId(caseInstanceId string) ApiGetTasksCountRequest {
	r.caseInstanceId = &caseInstanceId
	return r
}

// Restrict to tasks that belong to case instances with the given business key.
func (r ApiGetTasksCountRequest) CaseInstanceBusinessKey(caseInstanceBusinessKey string) ApiGetTasksCountRequest {
	r.caseInstanceBusinessKey = &caseInstanceBusinessKey
	return r
}

// Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
func (r ApiGetTasksCountRequest) CaseInstanceBusinessKeyLike(caseInstanceBusinessKeyLike string) ApiGetTasksCountRequest {
	r.caseInstanceBusinessKeyLike = &caseInstanceBusinessKeyLike
	return r
}

// Restrict to tasks that belong to a case definition with the given id.
func (r ApiGetTasksCountRequest) CaseDefinitionId(caseDefinitionId string) ApiGetTasksCountRequest {
	r.caseDefinitionId = &caseDefinitionId
	return r
}

// Restrict to tasks that belong to a case definition with the given key.
func (r ApiGetTasksCountRequest) CaseDefinitionKey(caseDefinitionKey string) ApiGetTasksCountRequest {
	r.caseDefinitionKey = &caseDefinitionKey
	return r
}

// Restrict to tasks that belong to a case definition with the given name.
func (r ApiGetTasksCountRequest) CaseDefinitionName(caseDefinitionName string) ApiGetTasksCountRequest {
	r.caseDefinitionName = &caseDefinitionName
	return r
}

// Restrict to tasks that have a case definition name that has the parameter value as a  substring.
func (r ApiGetTasksCountRequest) CaseDefinitionNameLike(caseDefinitionNameLike string) ApiGetTasksCountRequest {
	r.caseDefinitionNameLike = &caseDefinitionNameLike
	return r
}

// Restrict to tasks that belong to a case execution with the given id.
func (r ApiGetTasksCountRequest) CaseExecutionId(caseExecutionId string) ApiGetTasksCountRequest {
	r.caseExecutionId = &caseExecutionId
	return r
}

// Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
func (r ApiGetTasksCountRequest) ActivityInstanceIdIn(activityInstanceIdIn string) ApiGetTasksCountRequest {
	r.activityInstanceIdIn = &activityInstanceIdIn
	return r
}

// Only include tasks which belong to one of the passed and comma-separated  tenant ids.
func (r ApiGetTasksCountRequest) TenantIdIn(tenantIdIn string) ApiGetTasksCountRequest {
	r.tenantIdIn = &tenantIdIn
	return r
}

// Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithoutTenantId(withoutTenantId bool) ApiGetTasksCountRequest {
	r.withoutTenantId = &withoutTenantId
	return r
}

// Restrict to tasks that the given user is assigned to.
func (r ApiGetTasksCountRequest) Assignee(assignee string) ApiGetTasksCountRequest {
	r.assignee = &assignee
	return r
}

// Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksCountRequest) AssigneeExpression(assigneeExpression string) ApiGetTasksCountRequest {
	r.assigneeExpression = &assigneeExpression
	return r
}

// Restrict to tasks that have an assignee that has the parameter  value as a substring.
func (r ApiGetTasksCountRequest) AssigneeLike(assigneeLike string) ApiGetTasksCountRequest {
	r.assigneeLike = &assigneeLike
	return r
}

// Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksCountRequest) AssigneeLikeExpression(assigneeLikeExpression string) ApiGetTasksCountRequest {
	r.assigneeLikeExpression = &assigneeLikeExpression
	return r
}

// Only include tasks which are assigned to one of the passed and  comma-separated user ids.
func (r ApiGetTasksCountRequest) AssigneeIn(assigneeIn string) ApiGetTasksCountRequest {
	r.assigneeIn = &assigneeIn
	return r
}

// Only include tasks which are not assigned to one of the passed and comma-separated user ids.
func (r ApiGetTasksCountRequest) AssigneeNotIn(assigneeNotIn string) ApiGetTasksCountRequest {
	r.assigneeNotIn = &assigneeNotIn
	return r
}

// Restrict to tasks that the given user owns.
func (r ApiGetTasksCountRequest) Owner(owner string) ApiGetTasksCountRequest {
	r.owner = &owner
	return r
}

// Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksCountRequest) OwnerExpression(ownerExpression string) ApiGetTasksCountRequest {
	r.ownerExpression = &ownerExpression
	return r
}

// Only include tasks that are offered to the given group.
func (r ApiGetTasksCountRequest) CandidateGroup(candidateGroup string) ApiGetTasksCountRequest {
	r.candidateGroup = &candidateGroup
	return r
}

// Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksCountRequest) CandidateGroupExpression(candidateGroupExpression string) ApiGetTasksCountRequest {
	r.candidateGroupExpression = &candidateGroupExpression
	return r
}

// Only include tasks that are offered to the given user or to one of his groups.
func (r ApiGetTasksCountRequest) CandidateUser(candidateUser string) ApiGetTasksCountRequest {
	r.candidateUser = &candidateUser
	return r
}

// Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
func (r ApiGetTasksCountRequest) CandidateUserExpression(candidateUserExpression string) ApiGetTasksCountRequest {
	r.candidateUserExpression = &candidateUserExpression
	return r
}

// Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
func (r ApiGetTasksCountRequest) IncludeAssignedTasks(includeAssignedTasks bool) ApiGetTasksCountRequest {
	r.includeAssignedTasks = &includeAssignedTasks
	return r
}

// Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
func (r ApiGetTasksCountRequest) InvolvedUser(involvedUser string) ApiGetTasksCountRequest {
	r.involvedUser = &involvedUser
	return r
}

// Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
func (r ApiGetTasksCountRequest) InvolvedUserExpression(involvedUserExpression string) ApiGetTasksCountRequest {
	r.involvedUserExpression = &involvedUserExpression
	return r
}

// If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
func (r ApiGetTasksCountRequest) Assigned(assigned bool) ApiGetTasksCountRequest {
	r.assigned = &assigned
	return r
}

// If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
func (r ApiGetTasksCountRequest) Unassigned(unassigned bool) ApiGetTasksCountRequest {
	r.unassigned = &unassigned
	return r
}

// Restrict to tasks that have the given key.
func (r ApiGetTasksCountRequest) TaskDefinitionKey(taskDefinitionKey string) ApiGetTasksCountRequest {
	r.taskDefinitionKey = &taskDefinitionKey
	return r
}

// Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
func (r ApiGetTasksCountRequest) TaskDefinitionKeyIn(taskDefinitionKeyIn string) ApiGetTasksCountRequest {
	r.taskDefinitionKeyIn = &taskDefinitionKeyIn
	return r
}

// Restrict to tasks that have a key that has the parameter value as a substring.
func (r ApiGetTasksCountRequest) TaskDefinitionKeyLike(taskDefinitionKeyLike string) ApiGetTasksCountRequest {
	r.taskDefinitionKeyLike = &taskDefinitionKeyLike
	return r
}

// Restrict to tasks that have the given name.
func (r ApiGetTasksCountRequest) Name(name string) ApiGetTasksCountRequest {
	r.name = &name
	return r
}

// Restrict to tasks that do not have the given name.
func (r ApiGetTasksCountRequest) NameNotEqual(nameNotEqual string) ApiGetTasksCountRequest {
	r.nameNotEqual = &nameNotEqual
	return r
}

// Restrict to tasks that have a name with the given parameter value as substring.
func (r ApiGetTasksCountRequest) NameLike(nameLike string) ApiGetTasksCountRequest {
	r.nameLike = &nameLike
	return r
}

// Restrict to tasks that do not have a name with the given parameter value as substring.
func (r ApiGetTasksCountRequest) NameNotLike(nameNotLike string) ApiGetTasksCountRequest {
	r.nameNotLike = &nameNotLike
	return r
}

// Restrict to tasks that have the given description.
func (r ApiGetTasksCountRequest) Description(description string) ApiGetTasksCountRequest {
	r.description = &description
	return r
}

// Restrict to tasks that have a description that has the parameter value as a substring.
func (r ApiGetTasksCountRequest) DescriptionLike(descriptionLike string) ApiGetTasksCountRequest {
	r.descriptionLike = &descriptionLike
	return r
}

// Restrict to tasks that have the given priority.
func (r ApiGetTasksCountRequest) Priority(priority int32) ApiGetTasksCountRequest {
	r.priority = &priority
	return r
}

// Restrict to tasks that have a lower or equal priority.
func (r ApiGetTasksCountRequest) MaxPriority(maxPriority int32) ApiGetTasksCountRequest {
	r.maxPriority = &maxPriority
	return r
}

// Restrict to tasks that have a higher or equal priority.
func (r ApiGetTasksCountRequest) MinPriority(minPriority int32) ApiGetTasksCountRequest {
	r.minPriority = &minPriority
	return r
}

// Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
func (r ApiGetTasksCountRequest) DueDate(dueDate string) ApiGetTasksCountRequest {
	r.dueDate = &dueDate
	return r
}

// Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) DueDateExpression(dueDateExpression string) ApiGetTasksCountRequest {
	r.dueDateExpression = &dueDateExpression
	return r
}

// Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
func (r ApiGetTasksCountRequest) DueAfter(dueAfter string) ApiGetTasksCountRequest {
	r.dueAfter = &dueAfter
	return r
}

// Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) DueAfterExpression(dueAfterExpression string) ApiGetTasksCountRequest {
	r.dueAfterExpression = &dueAfterExpression
	return r
}

// Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
func (r ApiGetTasksCountRequest) DueBefore(dueBefore string) ApiGetTasksCountRequest {
	r.dueBefore = &dueBefore
	return r
}

// Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) DueBeforeExpression(dueBeforeExpression string) ApiGetTasksCountRequest {
	r.dueBeforeExpression = &dueBeforeExpression
	return r
}

// Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithoutDueDate(withoutDueDate bool) ApiGetTasksCountRequest {
	r.withoutDueDate = &withoutDueDate
	return r
}

// Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
func (r ApiGetTasksCountRequest) FollowUpDate(followUpDate string) ApiGetTasksCountRequest {
	r.followUpDate = &followUpDate
	return r
}

// Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) FollowUpDateExpression(followUpDateExpression string) ApiGetTasksCountRequest {
	r.followUpDateExpression = &followUpDateExpression
	return r
}

// Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
func (r ApiGetTasksCountRequest) FollowUpAfter(followUpAfter string) ApiGetTasksCountRequest {
	r.followUpAfter = &followUpAfter
	return r
}

// Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) FollowUpAfterExpression(followUpAfterExpression string) ApiGetTasksCountRequest {
	r.followUpAfterExpression = &followUpAfterExpression
	return r
}

// Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
func (r ApiGetTasksCountRequest) FollowUpBefore(followUpBefore string) ApiGetTasksCountRequest {
	r.followUpBefore = &followUpBefore
	return r
}

// Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) FollowUpBeforeExpression(followUpBeforeExpression string) ApiGetTasksCountRequest {
	r.followUpBeforeExpression = &followUpBeforeExpression
	return r
}

// Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
func (r ApiGetTasksCountRequest) FollowUpBeforeOrNotExistent(followUpBeforeOrNotExistent string) ApiGetTasksCountRequest {
	r.followUpBeforeOrNotExistent = &followUpBeforeOrNotExistent
	return r
}

// Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) FollowUpBeforeOrNotExistentExpression(followUpBeforeOrNotExistentExpression string) ApiGetTasksCountRequest {
	r.followUpBeforeOrNotExistentExpression = &followUpBeforeOrNotExistentExpression
	return r
}

// Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
func (r ApiGetTasksCountRequest) CreatedOn(createdOn string) ApiGetTasksCountRequest {
	r.createdOn = &createdOn
	return r
}

// Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) CreatedOnExpression(createdOnExpression string) ApiGetTasksCountRequest {
	r.createdOnExpression = &createdOnExpression
	return r
}

// Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
func (r ApiGetTasksCountRequest) CreatedAfter(createdAfter string) ApiGetTasksCountRequest {
	r.createdAfter = &createdAfter
	return r
}

// Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) CreatedAfterExpression(createdAfterExpression string) ApiGetTasksCountRequest {
	r.createdAfterExpression = &createdAfterExpression
	return r
}

// Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
func (r ApiGetTasksCountRequest) CreatedBefore(createdBefore string) ApiGetTasksCountRequest {
	r.createdBefore = &createdBefore
	return r
}

// Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) CreatedBeforeExpression(createdBeforeExpression string) ApiGetTasksCountRequest {
	r.createdBeforeExpression = &createdBeforeExpression
	return r
}

// Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
func (r ApiGetTasksCountRequest) UpdatedAfter(updatedAfter string) ApiGetTasksCountRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
func (r ApiGetTasksCountRequest) UpdatedAfterExpression(updatedAfterExpression string) ApiGetTasksCountRequest {
	r.updatedAfterExpression = &updatedAfterExpression
	return r
}

// Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
func (r ApiGetTasksCountRequest) DelegationState(delegationState string) ApiGetTasksCountRequest {
	r.delegationState = &delegationState
	return r
}

// Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
func (r ApiGetTasksCountRequest) CandidateGroups(candidateGroups string) ApiGetTasksCountRequest {
	r.candidateGroups = &candidateGroups
	return r
}

// Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
func (r ApiGetTasksCountRequest) CandidateGroupsExpression(candidateGroupsExpression string) ApiGetTasksCountRequest {
	r.candidateGroupsExpression = &candidateGroupsExpression
	return r
}

// Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithCandidateGroups(withCandidateGroups bool) ApiGetTasksCountRequest {
	r.withCandidateGroups = &withCandidateGroups
	return r
}

// Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithoutCandidateGroups(withoutCandidateGroups bool) ApiGetTasksCountRequest {
	r.withoutCandidateGroups = &withoutCandidateGroups
	return r
}

// Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithCandidateUsers(withCandidateUsers bool) ApiGetTasksCountRequest {
	r.withCandidateUsers = &withCandidateUsers
	return r
}

// Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) WithoutCandidateUsers(withoutCandidateUsers bool) ApiGetTasksCountRequest {
	r.withoutCandidateUsers = &withoutCandidateUsers
	return r
}

// Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) Active(active bool) ApiGetTasksCountRequest {
	r.active = &active
	return r
}

// Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
func (r ApiGetTasksCountRequest) Suspended(suspended bool) ApiGetTasksCountRequest {
	r.suspended = &suspended
	return r
}

// Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksCountRequest) TaskVariables(taskVariables string) ApiGetTasksCountRequest {
	r.taskVariables = &taskVariables
	return r
}

// Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksCountRequest) ProcessVariables(processVariables string) ApiGetTasksCountRequest {
	r.processVariables = &processVariables
	return r
}

// Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
func (r ApiGetTasksCountRequest) CaseInstanceVariables(caseInstanceVariables string) ApiGetTasksCountRequest {
	r.caseInstanceVariables = &caseInstanceVariables
	return r
}

// Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
func (r ApiGetTasksCountRequest) VariableNamesIgnoreCase(variableNamesIgnoreCase bool) ApiGetTasksCountRequest {
	r.variableNamesIgnoreCase = &variableNamesIgnoreCase
	return r
}

// Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
func (r ApiGetTasksCountRequest) VariableValuesIgnoreCase(variableValuesIgnoreCase bool) ApiGetTasksCountRequest {
	r.variableValuesIgnoreCase = &variableValuesIgnoreCase
	return r
}

// Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
func (r ApiGetTasksCountRequest) ParentTaskId(parentTaskId string) ApiGetTasksCountRequest {
	r.parentTaskId = &parentTaskId
	return r
}

func (r ApiGetTasksCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.GetTasksCountExecute(r)
}

/*
GetTasksCount Get List Count

Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size
of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.21/reference/rest/task/) method.

**Security Consideration:** There are several query parameters (such as
assigneeExpression) for specifying an EL expression. These are disabled by default to
prevent remote code execution. See the section on
[security considerations](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/)
for custom code in the user guide for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTasksCountRequest
*/
func (a *TaskAPIService) GetTasksCount(ctx context.Context) ApiGetTasksCountRequest {
	return ApiGetTasksCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *TaskAPIService) GetTasksCountExecute(r ApiGetTasksCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.GetTasksCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskId", r.taskId, "")
	}
	if r.taskIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskIdIn", r.taskIdIn, "")
	}
	if r.processInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceId", r.processInstanceId, "")
	}
	if r.processInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceIdIn", r.processInstanceIdIn, "")
	}
	if r.processInstanceBusinessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKey", r.processInstanceBusinessKey, "")
	}
	if r.processInstanceBusinessKeyExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyExpression", r.processInstanceBusinessKeyExpression, "")
	}
	if r.processInstanceBusinessKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyIn", r.processInstanceBusinessKeyIn, "")
	}
	if r.processInstanceBusinessKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyLike", r.processInstanceBusinessKeyLike, "")
	}
	if r.processInstanceBusinessKeyLikeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processInstanceBusinessKeyLikeExpression", r.processInstanceBusinessKeyLikeExpression, "")
	}
	if r.processDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionId", r.processDefinitionId, "")
	}
	if r.processDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKey", r.processDefinitionKey, "")
	}
	if r.processDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionKeyIn", r.processDefinitionKeyIn, "")
	}
	if r.processDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionName", r.processDefinitionName, "")
	}
	if r.processDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processDefinitionNameLike", r.processDefinitionNameLike, "")
	}
	if r.executionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionId", r.executionId, "")
	}
	if r.caseInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceId", r.caseInstanceId, "")
	}
	if r.caseInstanceBusinessKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceBusinessKey", r.caseInstanceBusinessKey, "")
	}
	if r.caseInstanceBusinessKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceBusinessKeyLike", r.caseInstanceBusinessKeyLike, "")
	}
	if r.caseDefinitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionId", r.caseDefinitionId, "")
	}
	if r.caseDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionKey", r.caseDefinitionKey, "")
	}
	if r.caseDefinitionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionName", r.caseDefinitionName, "")
	}
	if r.caseDefinitionNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseDefinitionNameLike", r.caseDefinitionNameLike, "")
	}
	if r.caseExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseExecutionId", r.caseExecutionId, "")
	}
	if r.activityInstanceIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityInstanceIdIn", r.activityInstanceIdIn, "")
	}
	if r.tenantIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIdIn", r.tenantIdIn, "")
	}
	if r.withoutTenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutTenantId", r.withoutTenantId, "")
	} else {
		var defaultValue bool = false
		r.withoutTenantId = &defaultValue
	}
	if r.assignee != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignee", r.assignee, "")
	}
	if r.assigneeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeExpression", r.assigneeExpression, "")
	}
	if r.assigneeLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeLike", r.assigneeLike, "")
	}
	if r.assigneeLikeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeLikeExpression", r.assigneeLikeExpression, "")
	}
	if r.assigneeIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeIn", r.assigneeIn, "")
	}
	if r.assigneeNotIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeNotIn", r.assigneeNotIn, "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	}
	if r.ownerExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerExpression", r.ownerExpression, "")
	}
	if r.candidateGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroup", r.candidateGroup, "")
	}
	if r.candidateGroupExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupExpression", r.candidateGroupExpression, "")
	}
	if r.candidateUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateUser", r.candidateUser, "")
	}
	if r.candidateUserExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateUserExpression", r.candidateUserExpression, "")
	}
	if r.includeAssignedTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAssignedTasks", r.includeAssignedTasks, "")
	} else {
		var defaultValue bool = false
		r.includeAssignedTasks = &defaultValue
	}
	if r.involvedUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "involvedUser", r.involvedUser, "")
	}
	if r.involvedUserExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "involvedUserExpression", r.involvedUserExpression, "")
	}
	if r.assigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned", r.assigned, "")
	} else {
		var defaultValue bool = false
		r.assigned = &defaultValue
	}
	if r.unassigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unassigned", r.unassigned, "")
	} else {
		var defaultValue bool = false
		r.unassigned = &defaultValue
	}
	if r.taskDefinitionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKey", r.taskDefinitionKey, "")
	}
	if r.taskDefinitionKeyIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyIn", r.taskDefinitionKeyIn, "")
	}
	if r.taskDefinitionKeyLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDefinitionKeyLike", r.taskDefinitionKeyLike, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameNotEqual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameNotEqual", r.nameNotEqual, "")
	}
	if r.nameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLike", r.nameLike, "")
	}
	if r.nameNotLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameNotLike", r.nameNotLike, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.descriptionLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionLike", r.descriptionLike, "")
	}
	if r.priority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority", r.priority, "")
	}
	if r.maxPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxPriority", r.maxPriority, "")
	}
	if r.minPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minPriority", r.minPriority, "")
	}
	if r.dueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDate", r.dueDate, "")
	}
	if r.dueDateExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueDateExpression", r.dueDateExpression, "")
	}
	if r.dueAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueAfter", r.dueAfter, "")
	}
	if r.dueAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueAfterExpression", r.dueAfterExpression, "")
	}
	if r.dueBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueBefore", r.dueBefore, "")
	}
	if r.dueBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueBeforeExpression", r.dueBeforeExpression, "")
	}
	if r.withoutDueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutDueDate", r.withoutDueDate, "")
	} else {
		var defaultValue bool = false
		r.withoutDueDate = &defaultValue
	}
	if r.followUpDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDate", r.followUpDate, "")
	}
	if r.followUpDateExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpDateExpression", r.followUpDateExpression, "")
	}
	if r.followUpAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpAfter", r.followUpAfter, "")
	}
	if r.followUpAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpAfterExpression", r.followUpAfterExpression, "")
	}
	if r.followUpBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBefore", r.followUpBefore, "")
	}
	if r.followUpBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeExpression", r.followUpBeforeExpression, "")
	}
	if r.followUpBeforeOrNotExistent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeOrNotExistent", r.followUpBeforeOrNotExistent, "")
	}
	if r.followUpBeforeOrNotExistentExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUpBeforeOrNotExistentExpression", r.followUpBeforeOrNotExistentExpression, "")
	}
	if r.createdOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOn", r.createdOn, "")
	}
	if r.createdOnExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdOnExpression", r.createdOnExpression, "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfter", r.createdAfter, "")
	}
	if r.createdAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfterExpression", r.createdAfterExpression, "")
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "")
	}
	if r.createdBeforeExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBeforeExpression", r.createdBeforeExpression, "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "")
	}
	if r.updatedAfterExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfterExpression", r.updatedAfterExpression, "")
	}
	if r.delegationState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delegationState", r.delegationState, "")
	}
	if r.candidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroups", r.candidateGroups, "")
	}
	if r.candidateGroupsExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "candidateGroupsExpression", r.candidateGroupsExpression, "")
	}
	if r.withCandidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCandidateGroups", r.withCandidateGroups, "")
	} else {
		var defaultValue bool = false
		r.withCandidateGroups = &defaultValue
	}
	if r.withoutCandidateGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutCandidateGroups", r.withoutCandidateGroups, "")
	} else {
		var defaultValue bool = false
		r.withoutCandidateGroups = &defaultValue
	}
	if r.withCandidateUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withCandidateUsers", r.withCandidateUsers, "")
	} else {
		var defaultValue bool = false
		r.withCandidateUsers = &defaultValue
	}
	if r.withoutCandidateUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withoutCandidateUsers", r.withoutCandidateUsers, "")
	} else {
		var defaultValue bool = false
		r.withoutCandidateUsers = &defaultValue
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	} else {
		var defaultValue bool = false
		r.active = &defaultValue
	}
	if r.suspended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suspended", r.suspended, "")
	} else {
		var defaultValue bool = false
		r.suspended = &defaultValue
	}
	if r.taskVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskVariables", r.taskVariables, "")
	}
	if r.processVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processVariables", r.processVariables, "")
	}
	if r.caseInstanceVariables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caseInstanceVariables", r.caseInstanceVariables, "")
	}
	if r.variableNamesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableNamesIgnoreCase", r.variableNamesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableNamesIgnoreCase = &defaultValue
	}
	if r.variableValuesIgnoreCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variableValuesIgnoreCase", r.variableValuesIgnoreCase, "")
	} else {
		var defaultValue bool = false
		r.variableValuesIgnoreCase = &defaultValue
	}
	if r.parentTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentTaskId", r.parentTaskId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHandleBpmnErrorRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	taskBpmnErrorDto *TaskBpmnErrorDto
}

func (r ApiHandleBpmnErrorRequest) TaskBpmnErrorDto(taskBpmnErrorDto TaskBpmnErrorDto) ApiHandleBpmnErrorRequest {
	r.taskBpmnErrorDto = &taskBpmnErrorDto
	return r
}

func (r ApiHandleBpmnErrorRequest) Execute() (*http.Response, error) {
	return r.ApiService.HandleBpmnErrorExecute(r)
}

/*
HandleBpmnError Handle BPMN Error

Reports a business error in the context of a running task by id. The error code must
be specified to identify the BPMN error handler. See the documentation for
[Reporting Bpmn Error](https://docs.camunda.org/manual/7.21/reference/bpmn20/tasks/user-task/#reporting-bpmn-error)
in User Tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task a BPMN error is reported for.
 @return ApiHandleBpmnErrorRequest
*/
func (a *TaskAPIService) HandleBpmnError(ctx context.Context, id string) ApiHandleBpmnErrorRequest {
	return ApiHandleBpmnErrorRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) HandleBpmnErrorExecute(r ApiHandleBpmnErrorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.HandleBpmnError")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/bpmnError"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskBpmnErrorDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiHandleEscalationRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	taskEscalationDto *TaskEscalationDto
}

func (r ApiHandleEscalationRequest) TaskEscalationDto(taskEscalationDto TaskEscalationDto) ApiHandleEscalationRequest {
	r.taskEscalationDto = &taskEscalationDto
	return r
}

func (r ApiHandleEscalationRequest) Execute() (*http.Response, error) {
	return r.ApiService.HandleEscalationExecute(r)
}

/*
HandleEscalation Handle BPMN Escalation

Reports an escalation in the context of a running task by id. The escalation code must
be specified to identify the escalation handler. See the documentation for
[Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.21/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation)
in User Tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task in which context a BPMN escalation is reported.
 @return ApiHandleEscalationRequest
*/
func (a *TaskAPIService) HandleEscalation(ctx context.Context, id string) ApiHandleEscalationRequest {
	return ApiHandleEscalationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) HandleEscalationExecute(r ApiHandleEscalationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.HandleEscalation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/bpmnEscalation"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskEscalationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AuthorizationExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryTasksRequest struct {
	ctx context.Context
	ApiService TaskAPI
	firstResult *int32
	maxResults *int32
	taskQueryDto *TaskQueryDto
}

// Pagination of results. Specifies the index of the first result to return.
func (r ApiQueryTasksRequest) FirstResult(firstResult int32) ApiQueryTasksRequest {
	r.firstResult = &firstResult
	return r
}

// Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
func (r ApiQueryTasksRequest) MaxResults(maxResults int32) ApiQueryTasksRequest {
	r.maxResults = &maxResults
	return r
}

func (r ApiQueryTasksRequest) TaskQueryDto(taskQueryDto TaskQueryDto) ApiQueryTasksRequest {
	r.taskQueryDto = &taskQueryDto
	return r
}

func (r ApiQueryTasksRequest) Execute() ([]TaskDto, *http.Response, error) {
	return r.ApiService.QueryTasksExecute(r)
}

/*
QueryTasks Get List (POST)

Queries for tasks that fulfill a given filter. This method is slightly more powerful
than the [Get Tasks](https://docs.camunda.org/manual/7.21/reference/rest/task/get-query/) method because it
allows filtering by multiple process or task variables of types `String`, `Number`
or `Boolean`. The size of the result set can be retrieved by using the
[Get Task Count (POST)](https://docs.camunda.org/manual/7.21/reference/rest/task/post-query-count/) method.

**Security Consideration**:
There are several parameters (such as `assigneeExpression`) for specifying an EL
expression. These are disabled by default to prevent remote code execution. See the
section on
[security considerations for custom code](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/)
in the user guide for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryTasksRequest
*/
func (a *TaskAPIService) QueryTasks(ctx context.Context) ApiQueryTasksRequest {
	return ApiQueryTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TaskDto
func (a *TaskAPIService) QueryTasksExecute(r ApiQueryTasksRequest) ([]TaskDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaskDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.QueryTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.firstResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstResult", r.firstResult, "")
	}
	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryTasksCountRequest struct {
	ctx context.Context
	ApiService TaskAPI
	taskQueryDto *TaskQueryDto
}

func (r ApiQueryTasksCountRequest) TaskQueryDto(taskQueryDto TaskQueryDto) ApiQueryTasksCountRequest {
	r.taskQueryDto = &taskQueryDto
	return r
}

func (r ApiQueryTasksCountRequest) Execute() (*CountResultDto, *http.Response, error) {
	return r.ApiService.QueryTasksCountExecute(r)
}

/*
QueryTasksCount Get List Count (POST)

Retrieves the number of tasks that fulfill the given filter. Corresponds to the size
of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.21/reference/rest/task/post-query/)
method and takes the same parameters.

**Security Consideration**:
There are several parameters (such as `assigneeExpression`) for specifying an EL
expression. These are disabled by default to prevent remote code execution. See the
section on
[security considerations for custom code](https://docs.camunda.org/manual/7.21/user-guide/process-engine/securing-custom-code/)
in the user guide for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryTasksCountRequest
*/
func (a *TaskAPIService) QueryTasksCount(ctx context.Context) ApiQueryTasksCountRequest {
	return ApiQueryTasksCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountResultDto
func (a *TaskAPIService) QueryTasksCountExecute(r ApiQueryTasksCountRequest) (*CountResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.QueryTasksCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskQueryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResolveRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	completeTaskDto *CompleteTaskDto
}

func (r ApiResolveRequest) CompleteTaskDto(completeTaskDto CompleteTaskDto) ApiResolveRequest {
	r.completeTaskDto = &completeTaskDto
	return r
}

func (r ApiResolveRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResolveExecute(r)
}

/*
Resolve Resolve

Resolves a task and updates execution variables.

Resolving a task marks that the assignee is done with the task delegated to them, and
that it can be sent back to the owner. Can only be executed when the task has been
delegated. The assignee will be set to the owner, who performed the delegation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to resolve.
 @return ApiResolveRequest
*/
func (a *TaskAPIService) Resolve(ctx context.Context, id string) ApiResolveRequest {
	return ApiResolveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) ResolveExecute(r ApiResolveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Resolve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/resolve"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.completeTaskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetAssigneeRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	userIdDto *UserIdDto
}

// Provide the id of the user that will be the assignee of the task.
func (r ApiSetAssigneeRequest) UserIdDto(userIdDto UserIdDto) ApiSetAssigneeRequest {
	r.userIdDto = &userIdDto
	return r
}

func (r ApiSetAssigneeRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetAssigneeExecute(r)
}

/*
SetAssignee Set Assignee

Changes the assignee of a task to a specific user.

**Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.21/reference/rest/task/post-claim/)
method is that this method does not check if the task already has a user
assigned to it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to set the assignee for.
 @return ApiSetAssigneeRequest
*/
func (a *TaskAPIService) SetAssignee(ctx context.Context, id string) ApiSetAssigneeRequest {
	return ApiSetAssigneeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) SetAssigneeExecute(r ApiSetAssigneeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.SetAssignee")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/assignee"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userIdDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubmitRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	completeTaskDto *CompleteTaskDto
}

func (r ApiSubmitRequest) CompleteTaskDto(completeTaskDto CompleteTaskDto) ApiSubmitRequest {
	r.completeTaskDto = &completeTaskDto
	return r
}

func (r ApiSubmitRequest) Execute() (*map[string]VariableValueDto, *http.Response, error) {
	return r.ApiService.SubmitExecute(r)
}

/*
Submit Submit Form

Completes a task and updates process variables using a form submit. There are two
difference between this method and the `complete` method:

* If the task is in state `PENDING` - i.e., has been delegated before, it is not
completed but resolved. Otherwise it will be completed.
* If the task has Form Field Metadata defined, the process engine will perform backend
validation for any form fields which have validators defined.
See the
[Generated Task Forms](https://docs.camunda.org/manual/7.21/user-guide/task-forms/_index/#generated-task-forms)
section of the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to submit the form for.
 @return ApiSubmitRequest
*/
func (a *TaskAPIService) Submit(ctx context.Context, id string) ApiSubmitRequest {
	return ApiSubmitRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]VariableValueDto
func (a *TaskAPIService) SubmitExecute(r ApiSubmitRequest) (*map[string]VariableValueDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]VariableValueDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Submit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/submit-form"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.completeTaskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnclaimRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
}

func (r ApiUnclaimRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnclaimExecute(r)
}

/*
Unclaim Unclaim

Resets a task's assignee. If successful, the task is not assigned to a user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to unclaim.
 @return ApiUnclaimRequest
*/
func (a *TaskAPIService) Unclaim(ctx context.Context, id string) ApiUnclaimRequest {
	return ApiUnclaimRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) UnclaimExecute(r ApiUnclaimRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.Unclaim")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}/unclaim"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateTaskRequest struct {
	ctx context.Context
	ApiService TaskAPI
	id string
	taskDto *TaskDto
}

func (r ApiUpdateTaskRequest) TaskDto(taskDto TaskDto) ApiUpdateTaskRequest {
	r.taskDto = &taskDto
	return r
}

func (r ApiUpdateTaskRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateTaskExecute(r)
}

/*
UpdateTask Update

Updates a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the task to be updated.
 @return ApiUpdateTaskRequest
*/
func (a *TaskAPIService) UpdateTask(ctx context.Context, id string) ApiUpdateTaskRequest {
	return ApiUpdateTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TaskAPIService) UpdateTaskExecute(r ApiUpdateTaskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskAPIService.UpdateTask")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
